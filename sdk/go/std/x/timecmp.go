// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package std

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-std/sdk/go/std/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Compares two timestamps and returns a number that represents the ordering
//
//	of the instants those timestamps represent.
//	Timestamps are represented as strings using RFC 3339 "Date and time format" syntax.
//	Both timestamps must be strings adhering this syntax, i.e. "2017-11-22T00:00:00Z".
//	If 'timestamp_a' is before 'timestamp_b', -1 is returned.
//	If 'timestamp_a' is equal to 'timestamp_b', 0 is returned.
//	If 'timestamp_a' is after 'timestamp_b', 1 is returned.
func Timecmp(ctx *pulumi.Context, args *TimecmpArgs, opts ...pulumi.InvokeOption) (*TimecmpResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv TimecmpResult
	err := ctx.Invoke("std:index:timecmp", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

type TimecmpArgs struct {
	Timestampa string `pulumi:"timestampa"`
	Timestampb string `pulumi:"timestampb"`
}

type TimecmpResult struct {
	Result int `pulumi:"result"`
}

func TimecmpOutput(ctx *pulumi.Context, args TimecmpOutputArgs, opts ...pulumi.InvokeOption) TimecmpResultOutput {
	outputResult := pulumix.ApplyErr[*TimecmpArgs](args.ToOutput(), func(plainArgs *TimecmpArgs) (*TimecmpResult, error) {
		return Timecmp(ctx, plainArgs, opts...)
	})

	return pulumix.Cast[TimecmpResultOutput, *TimecmpResult](outputResult)
}

type TimecmpOutputArgs struct {
	Timestampa pulumix.Input[string] `pulumi:"timestampa"`
	Timestampb pulumix.Input[string] `pulumi:"timestampb"`
}

func (args TimecmpOutputArgs) ToOutput() pulumix.Output[*TimecmpArgs] {
	allArgs := pulumix.All(
		args.Timestampa.ToOutput(context.Background()).AsAny(),
		args.Timestampb.ToOutput(context.Background()).AsAny())
	return pulumix.Apply[[]any](allArgs, func(resolvedArgs []interface{}) *TimecmpArgs {
		return &TimecmpArgs{
			Timestampa: resolvedArgs[0].(string),
			Timestampb: resolvedArgs[1].(string),
		}
	})
}

type TimecmpResultOutput struct{ *pulumi.OutputState }

func (TimecmpResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TimecmpResult)(nil)).Elem()
}

func (o TimecmpResultOutput) ToOutput(context.Context) pulumix.Output[*TimecmpResult] {
	return pulumix.Output[*TimecmpResult]{
		OutputState: o.OutputState,
	}
}

func (o TimecmpResultOutput) Result() pulumix.Output[int] {
	return pulumix.Apply[*TimecmpResult](o, func(v *TimecmpResult) int { return v.Result })
}
