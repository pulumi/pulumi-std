// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.std;

import com.pulumi.core.Output;
import com.pulumi.core.TypeShape;
import com.pulumi.deployment.Deployment;
import com.pulumi.deployment.InvokeOptions;
import com.pulumi.std.Utilities;
import com.pulumi.std.inputs.AbsArgs;
import com.pulumi.std.inputs.AbsPlainArgs;
import com.pulumi.std.inputs.AbspathArgs;
import com.pulumi.std.inputs.AbspathPlainArgs;
import com.pulumi.std.inputs.AlltrueArgs;
import com.pulumi.std.inputs.AlltruePlainArgs;
import com.pulumi.std.inputs.AnytrueArgs;
import com.pulumi.std.inputs.AnytruePlainArgs;
import com.pulumi.std.inputs.Base64decodeArgs;
import com.pulumi.std.inputs.Base64decodePlainArgs;
import com.pulumi.std.inputs.Base64encodeArgs;
import com.pulumi.std.inputs.Base64encodePlainArgs;
import com.pulumi.std.inputs.Base64gzipArgs;
import com.pulumi.std.inputs.Base64gzipPlainArgs;
import com.pulumi.std.inputs.Base64sha256Args;
import com.pulumi.std.inputs.Base64sha256PlainArgs;
import com.pulumi.std.inputs.Base64sha512Args;
import com.pulumi.std.inputs.Base64sha512PlainArgs;
import com.pulumi.std.inputs.BasenameArgs;
import com.pulumi.std.inputs.BasenamePlainArgs;
import com.pulumi.std.inputs.BcryptArgs;
import com.pulumi.std.inputs.BcryptPlainArgs;
import com.pulumi.std.inputs.CeilArgs;
import com.pulumi.std.inputs.CeilPlainArgs;
import com.pulumi.std.inputs.ChompArgs;
import com.pulumi.std.inputs.ChompPlainArgs;
import com.pulumi.std.inputs.ChunklistArgs;
import com.pulumi.std.inputs.ChunklistPlainArgs;
import com.pulumi.std.inputs.CidrhostArgs;
import com.pulumi.std.inputs.CidrhostPlainArgs;
import com.pulumi.std.inputs.CidrnetmaskArgs;
import com.pulumi.std.inputs.CidrnetmaskPlainArgs;
import com.pulumi.std.inputs.CidrsubnetArgs;
import com.pulumi.std.inputs.CidrsubnetPlainArgs;
import com.pulumi.std.inputs.CoalesceArgs;
import com.pulumi.std.inputs.CoalescePlainArgs;
import com.pulumi.std.inputs.CoalescelistArgs;
import com.pulumi.std.inputs.CoalescelistPlainArgs;
import com.pulumi.std.inputs.CompactArgs;
import com.pulumi.std.inputs.CompactPlainArgs;
import com.pulumi.std.inputs.ConcatArgs;
import com.pulumi.std.inputs.ConcatPlainArgs;
import com.pulumi.std.inputs.ContainsArgs;
import com.pulumi.std.inputs.ContainsPlainArgs;
import com.pulumi.std.inputs.CsvdecodeArgs;
import com.pulumi.std.inputs.CsvdecodePlainArgs;
import com.pulumi.std.inputs.DirnameArgs;
import com.pulumi.std.inputs.DirnamePlainArgs;
import com.pulumi.std.inputs.DistinctArgs;
import com.pulumi.std.inputs.DistinctPlainArgs;
import com.pulumi.std.inputs.ElementArgs;
import com.pulumi.std.inputs.ElementPlainArgs;
import com.pulumi.std.inputs.EndswithArgs;
import com.pulumi.std.inputs.EndswithPlainArgs;
import com.pulumi.std.inputs.FileArgs;
import com.pulumi.std.inputs.FilePlainArgs;
import com.pulumi.std.inputs.Filebase64Args;
import com.pulumi.std.inputs.Filebase64PlainArgs;
import com.pulumi.std.inputs.Filebase64sha256Args;
import com.pulumi.std.inputs.Filebase64sha256PlainArgs;
import com.pulumi.std.inputs.Filebase64sha512Args;
import com.pulumi.std.inputs.Filebase64sha512PlainArgs;
import com.pulumi.std.inputs.FileexistsArgs;
import com.pulumi.std.inputs.FileexistsPlainArgs;
import com.pulumi.std.inputs.Filemd5Args;
import com.pulumi.std.inputs.Filemd5PlainArgs;
import com.pulumi.std.inputs.Filesha1Args;
import com.pulumi.std.inputs.Filesha1PlainArgs;
import com.pulumi.std.inputs.Filesha256Args;
import com.pulumi.std.inputs.Filesha256PlainArgs;
import com.pulumi.std.inputs.Filesha512Args;
import com.pulumi.std.inputs.Filesha512PlainArgs;
import com.pulumi.std.inputs.FlattenArgs;
import com.pulumi.std.inputs.FlattenPlainArgs;
import com.pulumi.std.inputs.FloorArgs;
import com.pulumi.std.inputs.FloorPlainArgs;
import com.pulumi.std.inputs.FormatArgs;
import com.pulumi.std.inputs.FormatPlainArgs;
import com.pulumi.std.inputs.IndentArgs;
import com.pulumi.std.inputs.IndentPlainArgs;
import com.pulumi.std.inputs.IndexArgs;
import com.pulumi.std.inputs.IndexPlainArgs;
import com.pulumi.std.inputs.JoinArgs;
import com.pulumi.std.inputs.JoinPlainArgs;
import com.pulumi.std.inputs.JsondecodeArgs;
import com.pulumi.std.inputs.JsondecodePlainArgs;
import com.pulumi.std.inputs.JsonencodeArgs;
import com.pulumi.std.inputs.JsonencodePlainArgs;
import com.pulumi.std.inputs.KeysArgs;
import com.pulumi.std.inputs.KeysPlainArgs;
import com.pulumi.std.inputs.LengthArgs;
import com.pulumi.std.inputs.LengthPlainArgs;
import com.pulumi.std.inputs.LogArgs;
import com.pulumi.std.inputs.LogPlainArgs;
import com.pulumi.std.inputs.LookupArgs;
import com.pulumi.std.inputs.LookupPlainArgs;
import com.pulumi.std.inputs.LowerArgs;
import com.pulumi.std.inputs.LowerPlainArgs;
import com.pulumi.std.inputs.MapArgs;
import com.pulumi.std.inputs.MapPlainArgs;
import com.pulumi.std.inputs.MatchkeysArgs;
import com.pulumi.std.inputs.MatchkeysPlainArgs;
import com.pulumi.std.inputs.MaxArgs;
import com.pulumi.std.inputs.MaxPlainArgs;
import com.pulumi.std.inputs.Md5Args;
import com.pulumi.std.inputs.Md5PlainArgs;
import com.pulumi.std.inputs.MergeArgs;
import com.pulumi.std.inputs.MergePlainArgs;
import com.pulumi.std.inputs.MinArgs;
import com.pulumi.std.inputs.MinPlainArgs;
import com.pulumi.std.inputs.ParseintArgs;
import com.pulumi.std.inputs.ParseintPlainArgs;
import com.pulumi.std.inputs.PathexpandArgs;
import com.pulumi.std.inputs.PathexpandPlainArgs;
import com.pulumi.std.inputs.PowArgs;
import com.pulumi.std.inputs.PowPlainArgs;
import com.pulumi.std.inputs.RangeArgs;
import com.pulumi.std.inputs.RangePlainArgs;
import com.pulumi.std.inputs.ReplaceArgs;
import com.pulumi.std.inputs.ReplacePlainArgs;
import com.pulumi.std.inputs.ReverseArgs;
import com.pulumi.std.inputs.ReversePlainArgs;
import com.pulumi.std.inputs.Rfc3339tounixArgs;
import com.pulumi.std.inputs.Rfc3339tounixPlainArgs;
import com.pulumi.std.inputs.RsadecryptArgs;
import com.pulumi.std.inputs.RsadecryptPlainArgs;
import com.pulumi.std.inputs.Sha1Args;
import com.pulumi.std.inputs.Sha1PlainArgs;
import com.pulumi.std.inputs.Sha256Args;
import com.pulumi.std.inputs.Sha256PlainArgs;
import com.pulumi.std.inputs.Sha512Args;
import com.pulumi.std.inputs.Sha512PlainArgs;
import com.pulumi.std.inputs.SignumArgs;
import com.pulumi.std.inputs.SignumPlainArgs;
import com.pulumi.std.inputs.SliceArgs;
import com.pulumi.std.inputs.SlicePlainArgs;
import com.pulumi.std.inputs.SortArgs;
import com.pulumi.std.inputs.SortPlainArgs;
import com.pulumi.std.inputs.SplitArgs;
import com.pulumi.std.inputs.SplitPlainArgs;
import com.pulumi.std.inputs.StartswithArgs;
import com.pulumi.std.inputs.StartswithPlainArgs;
import com.pulumi.std.inputs.StrrevArgs;
import com.pulumi.std.inputs.StrrevPlainArgs;
import com.pulumi.std.inputs.SubstrArgs;
import com.pulumi.std.inputs.SubstrPlainArgs;
import com.pulumi.std.inputs.SumArgs;
import com.pulumi.std.inputs.SumPlainArgs;
import com.pulumi.std.inputs.TimeaddArgs;
import com.pulumi.std.inputs.TimeaddPlainArgs;
import com.pulumi.std.inputs.TimecmpArgs;
import com.pulumi.std.inputs.TimecmpPlainArgs;
import com.pulumi.std.inputs.TimestampArgs;
import com.pulumi.std.inputs.TimestampPlainArgs;
import com.pulumi.std.inputs.TitleArgs;
import com.pulumi.std.inputs.TitlePlainArgs;
import com.pulumi.std.inputs.ToboolArgs;
import com.pulumi.std.inputs.ToboolPlainArgs;
import com.pulumi.std.inputs.TolistArgs;
import com.pulumi.std.inputs.TolistPlainArgs;
import com.pulumi.std.inputs.TonumberArgs;
import com.pulumi.std.inputs.TonumberPlainArgs;
import com.pulumi.std.inputs.TosetArgs;
import com.pulumi.std.inputs.TosetPlainArgs;
import com.pulumi.std.inputs.TostringArgs;
import com.pulumi.std.inputs.TostringPlainArgs;
import com.pulumi.std.inputs.TransposeArgs;
import com.pulumi.std.inputs.TransposePlainArgs;
import com.pulumi.std.inputs.TrimArgs;
import com.pulumi.std.inputs.TrimPlainArgs;
import com.pulumi.std.inputs.TrimprefixArgs;
import com.pulumi.std.inputs.TrimprefixPlainArgs;
import com.pulumi.std.inputs.TrimspaceArgs;
import com.pulumi.std.inputs.TrimspacePlainArgs;
import com.pulumi.std.inputs.TrimsuffixArgs;
import com.pulumi.std.inputs.TrimsuffixPlainArgs;
import com.pulumi.std.inputs.Unixtorfc3999Args;
import com.pulumi.std.inputs.Unixtorfc3999PlainArgs;
import com.pulumi.std.inputs.UpperArgs;
import com.pulumi.std.inputs.UpperPlainArgs;
import com.pulumi.std.inputs.UrlencodeArgs;
import com.pulumi.std.inputs.UrlencodePlainArgs;
import com.pulumi.std.inputs.UuidArgs;
import com.pulumi.std.inputs.UuidPlainArgs;
import com.pulumi.std.inputs.ValuesArgs;
import com.pulumi.std.inputs.ValuesPlainArgs;
import com.pulumi.std.inputs.ZipmapArgs;
import com.pulumi.std.inputs.ZipmapPlainArgs;
import com.pulumi.std.outputs.AbsResult;
import com.pulumi.std.outputs.AbspathResult;
import com.pulumi.std.outputs.AlltrueResult;
import com.pulumi.std.outputs.AnytrueResult;
import com.pulumi.std.outputs.Base64decodeResult;
import com.pulumi.std.outputs.Base64encodeResult;
import com.pulumi.std.outputs.Base64gzipResult;
import com.pulumi.std.outputs.Base64sha256Result;
import com.pulumi.std.outputs.Base64sha512Result;
import com.pulumi.std.outputs.BasenameResult;
import com.pulumi.std.outputs.BcryptResult;
import com.pulumi.std.outputs.CeilResult;
import com.pulumi.std.outputs.ChompResult;
import com.pulumi.std.outputs.ChunklistResult;
import com.pulumi.std.outputs.CidrhostResult;
import com.pulumi.std.outputs.CidrnetmaskResult;
import com.pulumi.std.outputs.CidrsubnetResult;
import com.pulumi.std.outputs.CoalesceResult;
import com.pulumi.std.outputs.CoalescelistResult;
import com.pulumi.std.outputs.CompactResult;
import com.pulumi.std.outputs.ConcatResult;
import com.pulumi.std.outputs.ContainsResult;
import com.pulumi.std.outputs.CsvdecodeResult;
import com.pulumi.std.outputs.DirnameResult;
import com.pulumi.std.outputs.DistinctResult;
import com.pulumi.std.outputs.ElementResult;
import com.pulumi.std.outputs.EndswithResult;
import com.pulumi.std.outputs.FileResult;
import com.pulumi.std.outputs.Filebase64Result;
import com.pulumi.std.outputs.Filebase64sha256Result;
import com.pulumi.std.outputs.Filebase64sha512Result;
import com.pulumi.std.outputs.FileexistsResult;
import com.pulumi.std.outputs.Filemd5Result;
import com.pulumi.std.outputs.Filesha1Result;
import com.pulumi.std.outputs.Filesha256Result;
import com.pulumi.std.outputs.Filesha512Result;
import com.pulumi.std.outputs.FlattenResult;
import com.pulumi.std.outputs.FloorResult;
import com.pulumi.std.outputs.FormatResult;
import com.pulumi.std.outputs.IndentResult;
import com.pulumi.std.outputs.IndexResult;
import com.pulumi.std.outputs.JoinResult;
import com.pulumi.std.outputs.JsondecodeResult;
import com.pulumi.std.outputs.JsonencodeResult;
import com.pulumi.std.outputs.KeysResult;
import com.pulumi.std.outputs.LengthResult;
import com.pulumi.std.outputs.LogResult;
import com.pulumi.std.outputs.LookupResult;
import com.pulumi.std.outputs.LowerResult;
import com.pulumi.std.outputs.MapResult;
import com.pulumi.std.outputs.MatchkeysResult;
import com.pulumi.std.outputs.MaxResult;
import com.pulumi.std.outputs.Md5Result;
import com.pulumi.std.outputs.MergeResult;
import com.pulumi.std.outputs.MinResult;
import com.pulumi.std.outputs.ParseintResult;
import com.pulumi.std.outputs.PathexpandResult;
import com.pulumi.std.outputs.PowResult;
import com.pulumi.std.outputs.RangeResult;
import com.pulumi.std.outputs.ReplaceResult;
import com.pulumi.std.outputs.ReverseResult;
import com.pulumi.std.outputs.Rfc3339tounixResult;
import com.pulumi.std.outputs.RsadecryptResult;
import com.pulumi.std.outputs.Sha1Result;
import com.pulumi.std.outputs.Sha256Result;
import com.pulumi.std.outputs.Sha512Result;
import com.pulumi.std.outputs.SignumResult;
import com.pulumi.std.outputs.SliceResult;
import com.pulumi.std.outputs.SortResult;
import com.pulumi.std.outputs.SplitResult;
import com.pulumi.std.outputs.StartswithResult;
import com.pulumi.std.outputs.StrrevResult;
import com.pulumi.std.outputs.SubstrResult;
import com.pulumi.std.outputs.SumResult;
import com.pulumi.std.outputs.TimeaddResult;
import com.pulumi.std.outputs.TimecmpResult;
import com.pulumi.std.outputs.TimestampResult;
import com.pulumi.std.outputs.TitleResult;
import com.pulumi.std.outputs.ToboolResult;
import com.pulumi.std.outputs.TolistResult;
import com.pulumi.std.outputs.TonumberResult;
import com.pulumi.std.outputs.TosetResult;
import com.pulumi.std.outputs.TostringResult;
import com.pulumi.std.outputs.TransposeResult;
import com.pulumi.std.outputs.TrimResult;
import com.pulumi.std.outputs.TrimprefixResult;
import com.pulumi.std.outputs.TrimspaceResult;
import com.pulumi.std.outputs.TrimsuffixResult;
import com.pulumi.std.outputs.Unixtorfc3999Result;
import com.pulumi.std.outputs.UpperResult;
import com.pulumi.std.outputs.UrlencodeResult;
import com.pulumi.std.outputs.UuidResult;
import com.pulumi.std.outputs.ValuesResult;
import com.pulumi.std.outputs.ZipmapResult;
import java.util.concurrent.CompletableFuture;

public final class StdFunctions {
    /**
     * Returns the absolute value of a given float.
     * Example: abs(1) returns 1, and abs(-1) would also return 1, whereas abs(-3.14) would return 3.14.
     * 
     */
    public static Output<AbsResult> abs(AbsArgs args) {
        return abs(args, InvokeOptions.Empty);
    }
    /**
     * Returns the absolute value of a given float.
     * Example: abs(1) returns 1, and abs(-1) would also return 1, whereas abs(-3.14) would return 3.14.
     * 
     */
    public static CompletableFuture<AbsResult> absPlain(AbsPlainArgs args) {
        return absPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the absolute value of a given float.
     * Example: abs(1) returns 1, and abs(-1) would also return 1, whereas abs(-3.14) would return 3.14.
     * 
     */
    public static Output<AbsResult> abs(AbsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:abs", TypeShape.of(AbsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the absolute value of a given float.
     * Example: abs(1) returns 1, and abs(-1) would also return 1, whereas abs(-3.14) would return 3.14.
     * 
     */
    public static CompletableFuture<AbsResult> absPlain(AbsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:abs", TypeShape.of(AbsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns an absolute representation of the specified path.
     * If the path is not absolute it will be joined with the current working directory to turn it into an absolute path.
     * 
     */
    public static Output<AbspathResult> abspath(AbspathArgs args) {
        return abspath(args, InvokeOptions.Empty);
    }
    /**
     * Returns an absolute representation of the specified path.
     * If the path is not absolute it will be joined with the current working directory to turn it into an absolute path.
     * 
     */
    public static CompletableFuture<AbspathResult> abspathPlain(AbspathPlainArgs args) {
        return abspathPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns an absolute representation of the specified path.
     * If the path is not absolute it will be joined with the current working directory to turn it into an absolute path.
     * 
     */
    public static Output<AbspathResult> abspath(AbspathArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:abspath", TypeShape.of(AbspathResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns an absolute representation of the specified path.
     * If the path is not absolute it will be joined with the current working directory to turn it into an absolute path.
     * 
     */
    public static CompletableFuture<AbspathResult> abspathPlain(AbspathPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:abspath", TypeShape.of(AbspathResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns true if all elements in a given collection are true or \&#34;true\&#34;.
     * It also returns true if the collection is empty.
     * 
     */
    public static Output<AlltrueResult> alltrue(AlltrueArgs args) {
        return alltrue(args, InvokeOptions.Empty);
    }
    /**
     * Returns true if all elements in a given collection are true or \&#34;true\&#34;.
     * It also returns true if the collection is empty.
     * 
     */
    public static CompletableFuture<AlltrueResult> alltruePlain(AlltruePlainArgs args) {
        return alltruePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns true if all elements in a given collection are true or \&#34;true\&#34;.
     * It also returns true if the collection is empty.
     * 
     */
    public static Output<AlltrueResult> alltrue(AlltrueArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:alltrue", TypeShape.of(AlltrueResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns true if all elements in a given collection are true or \&#34;true\&#34;.
     * It also returns true if the collection is empty.
     * 
     */
    public static CompletableFuture<AlltrueResult> alltruePlain(AlltruePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:alltrue", TypeShape.of(AlltrueResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns true if any of the elements in a given collection are true or \&#34;true\&#34;.
     * It also returns false if the collection is empty.
     * 
     */
    public static Output<AnytrueResult> anytrue(AnytrueArgs args) {
        return anytrue(args, InvokeOptions.Empty);
    }
    /**
     * Returns true if any of the elements in a given collection are true or \&#34;true\&#34;.
     * It also returns false if the collection is empty.
     * 
     */
    public static CompletableFuture<AnytrueResult> anytruePlain(AnytruePlainArgs args) {
        return anytruePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns true if any of the elements in a given collection are true or \&#34;true\&#34;.
     * It also returns false if the collection is empty.
     * 
     */
    public static Output<AnytrueResult> anytrue(AnytrueArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:anytrue", TypeShape.of(AnytrueResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns true if any of the elements in a given collection are true or \&#34;true\&#34;.
     * It also returns false if the collection is empty.
     * 
     */
    public static CompletableFuture<AnytrueResult> anytruePlain(AnytruePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:anytrue", TypeShape.of(AnytrueResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Given a base64-encoded string, decodes it and returns the original string.
     * 
     */
    public static Output<Base64decodeResult> base64decode(Base64decodeArgs args) {
        return base64decode(args, InvokeOptions.Empty);
    }
    /**
     * Given a base64-encoded string, decodes it and returns the original string.
     * 
     */
    public static CompletableFuture<Base64decodeResult> base64decodePlain(Base64decodePlainArgs args) {
        return base64decodePlain(args, InvokeOptions.Empty);
    }
    /**
     * Given a base64-encoded string, decodes it and returns the original string.
     * 
     */
    public static Output<Base64decodeResult> base64decode(Base64decodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:base64decode", TypeShape.of(Base64decodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Given a base64-encoded string, decodes it and returns the original string.
     * 
     */
    public static CompletableFuture<Base64decodeResult> base64decodePlain(Base64decodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:base64decode", TypeShape.of(Base64decodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a base64-encoded representation of the given string.
     * 
     */
    public static Output<Base64encodeResult> base64encode(Base64encodeArgs args) {
        return base64encode(args, InvokeOptions.Empty);
    }
    /**
     * Returns a base64-encoded representation of the given string.
     * 
     */
    public static CompletableFuture<Base64encodeResult> base64encodePlain(Base64encodePlainArgs args) {
        return base64encodePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a base64-encoded representation of the given string.
     * 
     */
    public static Output<Base64encodeResult> base64encode(Base64encodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:base64encode", TypeShape.of(Base64encodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a base64-encoded representation of the given string.
     * 
     */
    public static CompletableFuture<Base64encodeResult> base64encodePlain(Base64encodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:base64encode", TypeShape.of(Base64encodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Compresses the given string with gzip and then encodes the result to base64.
     * 
     */
    public static Output<Base64gzipResult> base64gzip(Base64gzipArgs args) {
        return base64gzip(args, InvokeOptions.Empty);
    }
    /**
     * Compresses the given string with gzip and then encodes the result to base64.
     * 
     */
    public static CompletableFuture<Base64gzipResult> base64gzipPlain(Base64gzipPlainArgs args) {
        return base64gzipPlain(args, InvokeOptions.Empty);
    }
    /**
     * Compresses the given string with gzip and then encodes the result to base64.
     * 
     */
    public static Output<Base64gzipResult> base64gzip(Base64gzipArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:base64gzip", TypeShape.of(Base64gzipResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Compresses the given string with gzip and then encodes the result to base64.
     * 
     */
    public static CompletableFuture<Base64gzipResult> base64gzipPlain(Base64gzipPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:base64gzip", TypeShape.of(Base64gzipResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a base64-encoded representation of raw SHA-256 sum of the given string.
     * This is not equivalent of base64encode(sha256(string)) since sha256() returns hexadecimal representation.
     * 
     */
    public static Output<Base64sha256Result> base64sha256(Base64sha256Args args) {
        return base64sha256(args, InvokeOptions.Empty);
    }
    /**
     * Returns a base64-encoded representation of raw SHA-256 sum of the given string.
     * This is not equivalent of base64encode(sha256(string)) since sha256() returns hexadecimal representation.
     * 
     */
    public static CompletableFuture<Base64sha256Result> base64sha256Plain(Base64sha256PlainArgs args) {
        return base64sha256Plain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a base64-encoded representation of raw SHA-256 sum of the given string.
     * This is not equivalent of base64encode(sha256(string)) since sha256() returns hexadecimal representation.
     * 
     */
    public static Output<Base64sha256Result> base64sha256(Base64sha256Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:base64sha256", TypeShape.of(Base64sha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a base64-encoded representation of raw SHA-256 sum of the given string.
     * This is not equivalent of base64encode(sha256(string)) since sha256() returns hexadecimal representation.
     * 
     */
    public static CompletableFuture<Base64sha256Result> base64sha256Plain(Base64sha256PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:base64sha256", TypeShape.of(Base64sha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a base64-encoded representation of raw SHA-512 sum of the given string.
     * This is not equivalent of base64encode(sha512(string)) since sha512() returns hexadecimal representation.
     * 
     */
    public static Output<Base64sha512Result> base64sha512(Base64sha512Args args) {
        return base64sha512(args, InvokeOptions.Empty);
    }
    /**
     * Returns a base64-encoded representation of raw SHA-512 sum of the given string.
     * This is not equivalent of base64encode(sha512(string)) since sha512() returns hexadecimal representation.
     * 
     */
    public static CompletableFuture<Base64sha512Result> base64sha512Plain(Base64sha512PlainArgs args) {
        return base64sha512Plain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a base64-encoded representation of raw SHA-512 sum of the given string.
     * This is not equivalent of base64encode(sha512(string)) since sha512() returns hexadecimal representation.
     * 
     */
    public static Output<Base64sha512Result> base64sha512(Base64sha512Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:base64sha512", TypeShape.of(Base64sha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a base64-encoded representation of raw SHA-512 sum of the given string.
     * This is not equivalent of base64encode(sha512(string)) since sha512() returns hexadecimal representation.
     * 
     */
    public static CompletableFuture<Base64sha512Result> base64sha512Plain(Base64sha512PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:base64sha512", TypeShape.of(Base64sha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the last element of the input path.
     * 
     */
    public static Output<BasenameResult> basename(BasenameArgs args) {
        return basename(args, InvokeOptions.Empty);
    }
    /**
     * Returns the last element of the input path.
     * 
     */
    public static CompletableFuture<BasenameResult> basenamePlain(BasenamePlainArgs args) {
        return basenamePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the last element of the input path.
     * 
     */
    public static Output<BasenameResult> basename(BasenameArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:basename", TypeShape.of(BasenameResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the last element of the input path.
     * 
     */
    public static CompletableFuture<BasenameResult> basenamePlain(BasenamePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:basename", TypeShape.of(BasenameResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the Blowfish encrypted hash of the string at the given cost.
     * A default cost of 10 will be used if not provided.
     * 
     */
    public static Output<BcryptResult> bcrypt(BcryptArgs args) {
        return bcrypt(args, InvokeOptions.Empty);
    }
    /**
     * Returns the Blowfish encrypted hash of the string at the given cost.
     * A default cost of 10 will be used if not provided.
     * 
     */
    public static CompletableFuture<BcryptResult> bcryptPlain(BcryptPlainArgs args) {
        return bcryptPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the Blowfish encrypted hash of the string at the given cost.
     * A default cost of 10 will be used if not provided.
     * 
     */
    public static Output<BcryptResult> bcrypt(BcryptArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:bcrypt", TypeShape.of(BcryptResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the Blowfish encrypted hash of the string at the given cost.
     * A default cost of 10 will be used if not provided.
     * 
     */
    public static CompletableFuture<BcryptResult> bcryptPlain(BcryptPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:bcrypt", TypeShape.of(BcryptResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the least integer value greater than or equal to the argument.
     * 
     */
    public static Output<CeilResult> ceil(CeilArgs args) {
        return ceil(args, InvokeOptions.Empty);
    }
    /**
     * Returns the least integer value greater than or equal to the argument.
     * 
     */
    public static CompletableFuture<CeilResult> ceilPlain(CeilPlainArgs args) {
        return ceilPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the least integer value greater than or equal to the argument.
     * 
     */
    public static Output<CeilResult> ceil(CeilArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:ceil", TypeShape.of(CeilResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the least integer value greater than or equal to the argument.
     * 
     */
    public static CompletableFuture<CeilResult> ceilPlain(CeilPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:ceil", TypeShape.of(CeilResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes one or more newline characters from the end of the given string.
     * 
     */
    public static Output<ChompResult> chomp(ChompArgs args) {
        return chomp(args, InvokeOptions.Empty);
    }
    /**
     * Removes one or more newline characters from the end of the given string.
     * 
     */
    public static CompletableFuture<ChompResult> chompPlain(ChompPlainArgs args) {
        return chompPlain(args, InvokeOptions.Empty);
    }
    /**
     * Removes one or more newline characters from the end of the given string.
     * 
     */
    public static Output<ChompResult> chomp(ChompArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:chomp", TypeShape.of(ChompResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes one or more newline characters from the end of the given string.
     * 
     */
    public static CompletableFuture<ChompResult> chompPlain(ChompPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:chomp", TypeShape.of(ChompResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Splits a single list into multiple lists where each has at most the given number of elements.
     * 
     */
    public static Output<ChunklistResult> chunklist(ChunklistArgs args) {
        return chunklist(args, InvokeOptions.Empty);
    }
    /**
     * Splits a single list into multiple lists where each has at most the given number of elements.
     * 
     */
    public static CompletableFuture<ChunklistResult> chunklistPlain(ChunklistPlainArgs args) {
        return chunklistPlain(args, InvokeOptions.Empty);
    }
    /**
     * Splits a single list into multiple lists where each has at most the given number of elements.
     * 
     */
    public static Output<ChunklistResult> chunklist(ChunklistArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:chunklist", TypeShape.of(ChunklistResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Splits a single list into multiple lists where each has at most the given number of elements.
     * 
     */
    public static CompletableFuture<ChunklistResult> chunklistPlain(ChunklistPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:chunklist", TypeShape.of(ChunklistResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes an IP address range in CIDR notation as input
     * and creates an IP address with the given host number.
     * If given host number is negative, the count starts from the end of the range.
     * For example, cidrhost(&#34;10.0.0.0/8&#34;, 2) returns 10.0.0.2 and cidrhost(&#34;10.0.0.0/8&#34;, -2) returns 10.255.255.254.
     * 
     */
    public static Output<CidrhostResult> cidrhost(CidrhostArgs args) {
        return cidrhost(args, InvokeOptions.Empty);
    }
    /**
     * Takes an IP address range in CIDR notation as input
     * and creates an IP address with the given host number.
     * If given host number is negative, the count starts from the end of the range.
     * For example, cidrhost(&#34;10.0.0.0/8&#34;, 2) returns 10.0.0.2 and cidrhost(&#34;10.0.0.0/8&#34;, -2) returns 10.255.255.254.
     * 
     */
    public static CompletableFuture<CidrhostResult> cidrhostPlain(CidrhostPlainArgs args) {
        return cidrhostPlain(args, InvokeOptions.Empty);
    }
    /**
     * Takes an IP address range in CIDR notation as input
     * and creates an IP address with the given host number.
     * If given host number is negative, the count starts from the end of the range.
     * For example, cidrhost(&#34;10.0.0.0/8&#34;, 2) returns 10.0.0.2 and cidrhost(&#34;10.0.0.0/8&#34;, -2) returns 10.255.255.254.
     * 
     */
    public static Output<CidrhostResult> cidrhost(CidrhostArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:cidrhost", TypeShape.of(CidrhostResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes an IP address range in CIDR notation as input
     * and creates an IP address with the given host number.
     * If given host number is negative, the count starts from the end of the range.
     * For example, cidrhost(&#34;10.0.0.0/8&#34;, 2) returns 10.0.0.2 and cidrhost(&#34;10.0.0.0/8&#34;, -2) returns 10.255.255.254.
     * 
     */
    public static CompletableFuture<CidrhostResult> cidrhostPlain(CidrhostPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:cidrhost", TypeShape.of(CidrhostResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes an IP address range in CIDR notation and returns the address-formatted subnet mask format
     * that some systems expect for IPv4 interfaces.
     * For example, cidrnetmask(&#34;10.0.0.0/8&#34;) returns 255.0.0.0.
     * Not applicable to IPv6 networks since CIDR notation is the only valid notation for IPv6.
     * 
     */
    public static Output<CidrnetmaskResult> cidrnetmask(CidrnetmaskArgs args) {
        return cidrnetmask(args, InvokeOptions.Empty);
    }
    /**
     * Takes an IP address range in CIDR notation and returns the address-formatted subnet mask format
     * that some systems expect for IPv4 interfaces.
     * For example, cidrnetmask(&#34;10.0.0.0/8&#34;) returns 255.0.0.0.
     * Not applicable to IPv6 networks since CIDR notation is the only valid notation for IPv6.
     * 
     */
    public static CompletableFuture<CidrnetmaskResult> cidrnetmaskPlain(CidrnetmaskPlainArgs args) {
        return cidrnetmaskPlain(args, InvokeOptions.Empty);
    }
    /**
     * Takes an IP address range in CIDR notation and returns the address-formatted subnet mask format
     * that some systems expect for IPv4 interfaces.
     * For example, cidrnetmask(&#34;10.0.0.0/8&#34;) returns 255.0.0.0.
     * Not applicable to IPv6 networks since CIDR notation is the only valid notation for IPv6.
     * 
     */
    public static Output<CidrnetmaskResult> cidrnetmask(CidrnetmaskArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:cidrnetmask", TypeShape.of(CidrnetmaskResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes an IP address range in CIDR notation and returns the address-formatted subnet mask format
     * that some systems expect for IPv4 interfaces.
     * For example, cidrnetmask(&#34;10.0.0.0/8&#34;) returns 255.0.0.0.
     * Not applicable to IPv6 networks since CIDR notation is the only valid notation for IPv6.
     * 
     */
    public static CompletableFuture<CidrnetmaskResult> cidrnetmaskPlain(CidrnetmaskPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:cidrnetmask", TypeShape.of(CidrnetmaskResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes an IP address range in CIDR notation (like 10.0.0.0/8) and extends its prefix
     * to include an additional subnet number. For example, cidrsubnet(&#34;10.0.0.0/8&#34;, 8, 2) returns 10.2.0.0/16;
     * cidrsubnet(&#34;2607:f298:6051:516c::/64&#34;, 8, 2) returns 2607:f298:6051:516c:200::/72.
     * 
     */
    public static Output<CidrsubnetResult> cidrsubnet(CidrsubnetArgs args) {
        return cidrsubnet(args, InvokeOptions.Empty);
    }
    /**
     * Takes an IP address range in CIDR notation (like 10.0.0.0/8) and extends its prefix
     * to include an additional subnet number. For example, cidrsubnet(&#34;10.0.0.0/8&#34;, 8, 2) returns 10.2.0.0/16;
     * cidrsubnet(&#34;2607:f298:6051:516c::/64&#34;, 8, 2) returns 2607:f298:6051:516c:200::/72.
     * 
     */
    public static CompletableFuture<CidrsubnetResult> cidrsubnetPlain(CidrsubnetPlainArgs args) {
        return cidrsubnetPlain(args, InvokeOptions.Empty);
    }
    /**
     * Takes an IP address range in CIDR notation (like 10.0.0.0/8) and extends its prefix
     * to include an additional subnet number. For example, cidrsubnet(&#34;10.0.0.0/8&#34;, 8, 2) returns 10.2.0.0/16;
     * cidrsubnet(&#34;2607:f298:6051:516c::/64&#34;, 8, 2) returns 2607:f298:6051:516c:200::/72.
     * 
     */
    public static Output<CidrsubnetResult> cidrsubnet(CidrsubnetArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:cidrsubnet", TypeShape.of(CidrsubnetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes an IP address range in CIDR notation (like 10.0.0.0/8) and extends its prefix
     * to include an additional subnet number. For example, cidrsubnet(&#34;10.0.0.0/8&#34;, 8, 2) returns 10.2.0.0/16;
     * cidrsubnet(&#34;2607:f298:6051:516c::/64&#34;, 8, 2) returns 2607:f298:6051:516c:200::/72.
     * 
     */
    public static CompletableFuture<CidrsubnetResult> cidrsubnetPlain(CidrsubnetPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:cidrsubnet", TypeShape.of(CidrsubnetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the first non-empty value from the given arguments.
     * 
     */
    public static Output<CoalesceResult> coalesce(CoalesceArgs args) {
        return coalesce(args, InvokeOptions.Empty);
    }
    /**
     * Returns the first non-empty value from the given arguments.
     * 
     */
    public static CompletableFuture<CoalesceResult> coalescePlain(CoalescePlainArgs args) {
        return coalescePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the first non-empty value from the given arguments.
     * 
     */
    public static Output<CoalesceResult> coalesce(CoalesceArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:coalesce", TypeShape.of(CoalesceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the first non-empty value from the given arguments.
     * 
     */
    public static CompletableFuture<CoalesceResult> coalescePlain(CoalescePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:coalesce", TypeShape.of(CoalesceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the first non-empty list from the given list of lists.
     * 
     */
    public static Output<CoalescelistResult> coalescelist(CoalescelistArgs args) {
        return coalescelist(args, InvokeOptions.Empty);
    }
    /**
     * Returns the first non-empty list from the given list of lists.
     * 
     */
    public static CompletableFuture<CoalescelistResult> coalescelistPlain(CoalescelistPlainArgs args) {
        return coalescelistPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the first non-empty list from the given list of lists.
     * 
     */
    public static Output<CoalescelistResult> coalescelist(CoalescelistArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:coalescelist", TypeShape.of(CoalescelistResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the first non-empty list from the given list of lists.
     * 
     */
    public static CompletableFuture<CoalescelistResult> coalescelistPlain(CoalescelistPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:coalescelist", TypeShape.of(CoalescelistResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes empty string elements from a list.
     * 
     */
    public static Output<CompactResult> compact(CompactArgs args) {
        return compact(args, InvokeOptions.Empty);
    }
    /**
     * Removes empty string elements from a list.
     * 
     */
    public static CompletableFuture<CompactResult> compactPlain(CompactPlainArgs args) {
        return compactPlain(args, InvokeOptions.Empty);
    }
    /**
     * Removes empty string elements from a list.
     * 
     */
    public static Output<CompactResult> compact(CompactArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:compact", TypeShape.of(CompactResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes empty string elements from a list.
     * 
     */
    public static CompletableFuture<CompactResult> compactPlain(CompactPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:compact", TypeShape.of(CompactResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Combines two or more lists into a single list.
     * 
     */
    public static Output<ConcatResult> concat(ConcatArgs args) {
        return concat(args, InvokeOptions.Empty);
    }
    /**
     * Combines two or more lists into a single list.
     * 
     */
    public static CompletableFuture<ConcatResult> concatPlain(ConcatPlainArgs args) {
        return concatPlain(args, InvokeOptions.Empty);
    }
    /**
     * Combines two or more lists into a single list.
     * 
     */
    public static Output<ConcatResult> concat(ConcatArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:concat", TypeShape.of(ConcatResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Combines two or more lists into a single list.
     * 
     */
    public static CompletableFuture<ConcatResult> concatPlain(ConcatPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:concat", TypeShape.of(ConcatResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns true if a list contains the given element and returns false otherwise.
     * 
     */
    public static Output<ContainsResult> contains(ContainsArgs args) {
        return contains(args, InvokeOptions.Empty);
    }
    /**
     * Returns true if a list contains the given element and returns false otherwise.
     * 
     */
    public static CompletableFuture<ContainsResult> containsPlain(ContainsPlainArgs args) {
        return containsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns true if a list contains the given element and returns false otherwise.
     * 
     */
    public static Output<ContainsResult> contains(ContainsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:contains", TypeShape.of(ContainsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns true if a list contains the given element and returns false otherwise.
     * 
     */
    public static CompletableFuture<ContainsResult> containsPlain(ContainsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:contains", TypeShape.of(ContainsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Decodes a string containing CSV-formatted data and produces a list of maps representing that data.
     * 	The first line of the CSV data is interpreted as a &#34;header&#34; row: the values given
     * 	are used as the keys in the resulting maps.
     * 	Each subsequent line becomes a single map in the resulting list,
     * 	matching the keys from the header row with the given values by index.
     * 	All lines in the file must contain the same number of fields,
     * 	or this function will produce an error.
     * 	Follows the format defined in RFC 4180.
     * 
     */
    public static Output<CsvdecodeResult> csvdecode(CsvdecodeArgs args) {
        return csvdecode(args, InvokeOptions.Empty);
    }
    /**
     * Decodes a string containing CSV-formatted data and produces a list of maps representing that data.
     * 	The first line of the CSV data is interpreted as a &#34;header&#34; row: the values given
     * 	are used as the keys in the resulting maps.
     * 	Each subsequent line becomes a single map in the resulting list,
     * 	matching the keys from the header row with the given values by index.
     * 	All lines in the file must contain the same number of fields,
     * 	or this function will produce an error.
     * 	Follows the format defined in RFC 4180.
     * 
     */
    public static CompletableFuture<CsvdecodeResult> csvdecodePlain(CsvdecodePlainArgs args) {
        return csvdecodePlain(args, InvokeOptions.Empty);
    }
    /**
     * Decodes a string containing CSV-formatted data and produces a list of maps representing that data.
     * 	The first line of the CSV data is interpreted as a &#34;header&#34; row: the values given
     * 	are used as the keys in the resulting maps.
     * 	Each subsequent line becomes a single map in the resulting list,
     * 	matching the keys from the header row with the given values by index.
     * 	All lines in the file must contain the same number of fields,
     * 	or this function will produce an error.
     * 	Follows the format defined in RFC 4180.
     * 
     */
    public static Output<CsvdecodeResult> csvdecode(CsvdecodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:csvdecode", TypeShape.of(CsvdecodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Decodes a string containing CSV-formatted data and produces a list of maps representing that data.
     * 	The first line of the CSV data is interpreted as a &#34;header&#34; row: the values given
     * 	are used as the keys in the resulting maps.
     * 	Each subsequent line becomes a single map in the resulting list,
     * 	matching the keys from the header row with the given values by index.
     * 	All lines in the file must contain the same number of fields,
     * 	or this function will produce an error.
     * 	Follows the format defined in RFC 4180.
     * 
     */
    public static CompletableFuture<CsvdecodeResult> csvdecodePlain(CsvdecodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:csvdecode", TypeShape.of(CsvdecodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns all but the last element of path, typically the path&#39;s directory.
     * 
     */
    public static Output<DirnameResult> dirname(DirnameArgs args) {
        return dirname(args, InvokeOptions.Empty);
    }
    /**
     * Returns all but the last element of path, typically the path&#39;s directory.
     * 
     */
    public static CompletableFuture<DirnameResult> dirnamePlain(DirnamePlainArgs args) {
        return dirnamePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns all but the last element of path, typically the path&#39;s directory.
     * 
     */
    public static Output<DirnameResult> dirname(DirnameArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:dirname", TypeShape.of(DirnameResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns all but the last element of path, typically the path&#39;s directory.
     * 
     */
    public static CompletableFuture<DirnameResult> dirnamePlain(DirnamePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:dirname", TypeShape.of(DirnameResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes duplicate items from a list.
     * 
     */
    public static Output<DistinctResult> distinct(DistinctArgs args) {
        return distinct(args, InvokeOptions.Empty);
    }
    /**
     * Removes duplicate items from a list.
     * 
     */
    public static CompletableFuture<DistinctResult> distinctPlain(DistinctPlainArgs args) {
        return distinctPlain(args, InvokeOptions.Empty);
    }
    /**
     * Removes duplicate items from a list.
     * 
     */
    public static Output<DistinctResult> distinct(DistinctArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:distinct", TypeShape.of(DistinctResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes duplicate items from a list.
     * 
     */
    public static CompletableFuture<DistinctResult> distinctPlain(DistinctPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:distinct", TypeShape.of(DistinctResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the element at the specified index.
     * 
     */
    public static Output<ElementResult> element(ElementArgs args) {
        return element(args, InvokeOptions.Empty);
    }
    /**
     * Returns the element at the specified index.
     * 
     */
    public static CompletableFuture<ElementResult> elementPlain(ElementPlainArgs args) {
        return elementPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the element at the specified index.
     * 
     */
    public static Output<ElementResult> element(ElementArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:element", TypeShape.of(ElementResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the element at the specified index.
     * 
     */
    public static CompletableFuture<ElementResult> elementPlain(ElementPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:element", TypeShape.of(ElementResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines if the input string ends with the suffix.
     * 
     */
    public static Output<EndswithResult> endswith(EndswithArgs args) {
        return endswith(args, InvokeOptions.Empty);
    }
    /**
     * Determines if the input string ends with the suffix.
     * 
     */
    public static CompletableFuture<EndswithResult> endswithPlain(EndswithPlainArgs args) {
        return endswithPlain(args, InvokeOptions.Empty);
    }
    /**
     * Determines if the input string ends with the suffix.
     * 
     */
    public static Output<EndswithResult> endswith(EndswithArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:endswith", TypeShape.of(EndswithResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines if the input string ends with the suffix.
     * 
     */
    public static CompletableFuture<EndswithResult> endswithPlain(EndswithPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:endswith", TypeShape.of(EndswithResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into the string.
     * 
     */
    public static Output<FileResult> file(FileArgs args) {
        return file(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into the string.
     * 
     */
    public static CompletableFuture<FileResult> filePlain(FilePlainArgs args) {
        return filePlain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into the string.
     * 
     */
    public static Output<FileResult> file(FileArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:file", TypeShape.of(FileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into the string.
     * 
     */
    public static CompletableFuture<FileResult> filePlain(FilePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:file", TypeShape.of(FileResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file and returns them as a base64-encoded string.
     * 
     */
    public static Output<Filebase64Result> filebase64(Filebase64Args args) {
        return filebase64(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file and returns them as a base64-encoded string.
     * 
     */
    public static CompletableFuture<Filebase64Result> filebase64Plain(Filebase64PlainArgs args) {
        return filebase64Plain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file and returns them as a base64-encoded string.
     * 
     */
    public static Output<Filebase64Result> filebase64(Filebase64Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:filebase64", TypeShape.of(Filebase64Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file and returns them as a base64-encoded string.
     * 
     */
    public static CompletableFuture<Filebase64Result> filebase64Plain(Filebase64PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:filebase64", TypeShape.of(Filebase64Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA256 hash of it.
     * 
     */
    public static Output<Filebase64sha256Result> filebase64sha256(Filebase64sha256Args args) {
        return filebase64sha256(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA256 hash of it.
     * 
     */
    public static CompletableFuture<Filebase64sha256Result> filebase64sha256Plain(Filebase64sha256PlainArgs args) {
        return filebase64sha256Plain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA256 hash of it.
     * 
     */
    public static Output<Filebase64sha256Result> filebase64sha256(Filebase64sha256Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:filebase64sha256", TypeShape.of(Filebase64sha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA256 hash of it.
     * 
     */
    public static CompletableFuture<Filebase64sha256Result> filebase64sha256Plain(Filebase64sha256PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:filebase64sha256", TypeShape.of(Filebase64sha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA512 hash of it.
     * 
     */
    public static Output<Filebase64sha512Result> filebase64sha512(Filebase64sha512Args args) {
        return filebase64sha512(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA512 hash of it.
     * 
     */
    public static CompletableFuture<Filebase64sha512Result> filebase64sha512Plain(Filebase64sha512PlainArgs args) {
        return filebase64sha512Plain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA512 hash of it.
     * 
     */
    public static Output<Filebase64sha512Result> filebase64sha512(Filebase64sha512Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:filebase64sha512", TypeShape.of(Filebase64sha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the base64-encoded SHA512 hash of it.
     * 
     */
    public static CompletableFuture<Filebase64sha512Result> filebase64sha512Plain(Filebase64sha512PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:filebase64sha512", TypeShape.of(Filebase64sha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines whether a file exists at a given path.
     * 
     */
    public static Output<FileexistsResult> fileexists(FileexistsArgs args) {
        return fileexists(args, InvokeOptions.Empty);
    }
    /**
     * Determines whether a file exists at a given path.
     * 
     */
    public static CompletableFuture<FileexistsResult> fileexistsPlain(FileexistsPlainArgs args) {
        return fileexistsPlain(args, InvokeOptions.Empty);
    }
    /**
     * Determines whether a file exists at a given path.
     * 
     */
    public static Output<FileexistsResult> fileexists(FileexistsArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:fileexists", TypeShape.of(FileexistsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines whether a file exists at a given path.
     * 
     */
    public static CompletableFuture<FileexistsResult> fileexistsPlain(FileexistsPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:fileexists", TypeShape.of(FileexistsResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the MD5 hash of it.
     * 
     */
    public static Output<Filemd5Result> filemd5(Filemd5Args args) {
        return filemd5(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the MD5 hash of it.
     * 
     */
    public static CompletableFuture<Filemd5Result> filemd5Plain(Filemd5PlainArgs args) {
        return filemd5Plain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the MD5 hash of it.
     * 
     */
    public static Output<Filemd5Result> filemd5(Filemd5Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:filemd5", TypeShape.of(Filemd5Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the MD5 hash of it.
     * 
     */
    public static CompletableFuture<Filemd5Result> filemd5Plain(Filemd5PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:filemd5", TypeShape.of(Filemd5Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the SHA1 hash of it.
     * 
     */
    public static Output<Filesha1Result> filesha1(Filesha1Args args) {
        return filesha1(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the SHA1 hash of it.
     * 
     */
    public static CompletableFuture<Filesha1Result> filesha1Plain(Filesha1PlainArgs args) {
        return filesha1Plain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the SHA1 hash of it.
     * 
     */
    public static Output<Filesha1Result> filesha1(Filesha1Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:filesha1", TypeShape.of(Filesha1Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the SHA1 hash of it.
     * 
     */
    public static CompletableFuture<Filesha1Result> filesha1Plain(Filesha1PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:filesha1", TypeShape.of(Filesha1Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the SHA256 hash of it.
     * 
     */
    public static Output<Filesha256Result> filesha256(Filesha256Args args) {
        return filesha256(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the SHA256 hash of it.
     * 
     */
    public static CompletableFuture<Filesha256Result> filesha256Plain(Filesha256PlainArgs args) {
        return filesha256Plain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the SHA256 hash of it.
     * 
     */
    public static Output<Filesha256Result> filesha256(Filesha256Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:filesha256", TypeShape.of(Filesha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the SHA256 hash of it.
     * 
     */
    public static CompletableFuture<Filesha256Result> filesha256Plain(Filesha256PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:filesha256", TypeShape.of(Filesha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the SHA512 hash of it.
     * 
     */
    public static Output<Filesha512Result> filesha512(Filesha512Args args) {
        return filesha512(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the SHA512 hash of it.
     * 
     */
    public static CompletableFuture<Filesha512Result> filesha512Plain(Filesha512PlainArgs args) {
        return filesha512Plain(args, InvokeOptions.Empty);
    }
    /**
     * Reads the contents of a file into a string and returns the SHA512 hash of it.
     * 
     */
    public static Output<Filesha512Result> filesha512(Filesha512Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:filesha512", TypeShape.of(Filesha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Reads the contents of a file into a string and returns the SHA512 hash of it.
     * 
     */
    public static CompletableFuture<Filesha512Result> filesha512Plain(Filesha512PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:filesha512", TypeShape.of(Filesha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Flattens lists of lists down to a flat list of primitive values,
     * eliminating any nested lists recursively.
     * 
     */
    public static Output<FlattenResult> flatten(FlattenArgs args) {
        return flatten(args, InvokeOptions.Empty);
    }
    /**
     * Flattens lists of lists down to a flat list of primitive values,
     * eliminating any nested lists recursively.
     * 
     */
    public static CompletableFuture<FlattenResult> flattenPlain(FlattenPlainArgs args) {
        return flattenPlain(args, InvokeOptions.Empty);
    }
    /**
     * Flattens lists of lists down to a flat list of primitive values,
     * eliminating any nested lists recursively.
     * 
     */
    public static Output<FlattenResult> flatten(FlattenArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:flatten", TypeShape.of(FlattenResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Flattens lists of lists down to a flat list of primitive values,
     * eliminating any nested lists recursively.
     * 
     */
    public static CompletableFuture<FlattenResult> flattenPlain(FlattenPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:flatten", TypeShape.of(FlattenResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static Output<FloorResult> floor(FloorArgs args) {
        return floor(args, InvokeOptions.Empty);
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static CompletableFuture<FloorResult> floorPlain(FloorPlainArgs args) {
        return floorPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static Output<FloorResult> floor(FloorArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:floor", TypeShape.of(FloorResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static CompletableFuture<FloorResult> floorPlain(FloorPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:floor", TypeShape.of(FloorResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Formats a string according to the given format. The syntax for the format is standard sprintf syntax.
     * 
     */
    public static Output<FormatResult> format(FormatArgs args) {
        return format(args, InvokeOptions.Empty);
    }
    /**
     * Formats a string according to the given format. The syntax for the format is standard sprintf syntax.
     * 
     */
    public static CompletableFuture<FormatResult> formatPlain(FormatPlainArgs args) {
        return formatPlain(args, InvokeOptions.Empty);
    }
    /**
     * Formats a string according to the given format. The syntax for the format is standard sprintf syntax.
     * 
     */
    public static Output<FormatResult> format(FormatArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:format", TypeShape.of(FormatResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Formats a string according to the given format. The syntax for the format is standard sprintf syntax.
     * 
     */
    public static CompletableFuture<FormatResult> formatPlain(FormatPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:format", TypeShape.of(FormatResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Adds a given number of spaces after each newline character in the given string.
     * 
     */
    public static Output<IndentResult> indent(IndentArgs args) {
        return indent(args, InvokeOptions.Empty);
    }
    /**
     * Adds a given number of spaces after each newline character in the given string.
     * 
     */
    public static CompletableFuture<IndentResult> indentPlain(IndentPlainArgs args) {
        return indentPlain(args, InvokeOptions.Empty);
    }
    /**
     * Adds a given number of spaces after each newline character in the given string.
     * 
     */
    public static Output<IndentResult> indent(IndentArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:indent", TypeShape.of(IndentResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Adds a given number of spaces after each newline character in the given string.
     * 
     */
    public static CompletableFuture<IndentResult> indentPlain(IndentPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:indent", TypeShape.of(IndentResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Finds the index of a given element in a list.
     * 
     */
    public static Output<IndexResult> index(IndexArgs args) {
        return index(args, InvokeOptions.Empty);
    }
    /**
     * Finds the index of a given element in a list.
     * 
     */
    public static CompletableFuture<IndexResult> indexPlain(IndexPlainArgs args) {
        return indexPlain(args, InvokeOptions.Empty);
    }
    /**
     * Finds the index of a given element in a list.
     * 
     */
    public static Output<IndexResult> index(IndexArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:index", TypeShape.of(IndexResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Finds the index of a given element in a list.
     * 
     */
    public static CompletableFuture<IndexResult> indexPlain(IndexPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:index", TypeShape.of(IndexResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Joins the list with the delimiter for a resultant string.
     * 
     */
    public static Output<JoinResult> join(JoinArgs args) {
        return join(args, InvokeOptions.Empty);
    }
    /**
     * Joins the list with the delimiter for a resultant string.
     * 
     */
    public static CompletableFuture<JoinResult> joinPlain(JoinPlainArgs args) {
        return joinPlain(args, InvokeOptions.Empty);
    }
    /**
     * Joins the list with the delimiter for a resultant string.
     * 
     */
    public static Output<JoinResult> join(JoinArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:join", TypeShape.of(JoinResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Joins the list with the delimiter for a resultant string.
     * 
     */
    public static CompletableFuture<JoinResult> joinPlain(JoinPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:join", TypeShape.of(JoinResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Interprets a given string as JSON and returns a represetation
     * 	of the result of decoding that string.
     * 	If input is not valid JSON, the result will be the input unchanged.
     * 
     */
    public static Output<JsondecodeResult> jsondecode(JsondecodeArgs args) {
        return jsondecode(args, InvokeOptions.Empty);
    }
    /**
     * Interprets a given string as JSON and returns a represetation
     * 	of the result of decoding that string.
     * 	If input is not valid JSON, the result will be the input unchanged.
     * 
     */
    public static CompletableFuture<JsondecodeResult> jsondecodePlain(JsondecodePlainArgs args) {
        return jsondecodePlain(args, InvokeOptions.Empty);
    }
    /**
     * Interprets a given string as JSON and returns a represetation
     * 	of the result of decoding that string.
     * 	If input is not valid JSON, the result will be the input unchanged.
     * 
     */
    public static Output<JsondecodeResult> jsondecode(JsondecodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:jsondecode", TypeShape.of(JsondecodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Interprets a given string as JSON and returns a represetation
     * 	of the result of decoding that string.
     * 	If input is not valid JSON, the result will be the input unchanged.
     * 
     */
    public static CompletableFuture<JsondecodeResult> jsondecodePlain(JsondecodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:jsondecode", TypeShape.of(JsondecodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a JSON-encoded representation of the given value,
     * which can contain arbitrarily-nested lists and maps.
     * Note that if the value is a string then its value will be placed in quotes.
     * 
     */
    public static Output<JsonencodeResult> jsonencode(JsonencodeArgs args) {
        return jsonencode(args, InvokeOptions.Empty);
    }
    /**
     * Returns a JSON-encoded representation of the given value,
     * which can contain arbitrarily-nested lists and maps.
     * Note that if the value is a string then its value will be placed in quotes.
     * 
     */
    public static CompletableFuture<JsonencodeResult> jsonencodePlain(JsonencodePlainArgs args) {
        return jsonencodePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a JSON-encoded representation of the given value,
     * which can contain arbitrarily-nested lists and maps.
     * Note that if the value is a string then its value will be placed in quotes.
     * 
     */
    public static Output<JsonencodeResult> jsonencode(JsonencodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:jsonencode", TypeShape.of(JsonencodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a JSON-encoded representation of the given value,
     * which can contain arbitrarily-nested lists and maps.
     * Note that if the value is a string then its value will be placed in quotes.
     * 
     */
    public static CompletableFuture<JsonencodeResult> jsonencodePlain(JsonencodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:jsonencode", TypeShape.of(JsonencodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a lexically sorted list of the map keys.
     * 
     */
    public static Output<KeysResult> keys(KeysArgs args) {
        return keys(args, InvokeOptions.Empty);
    }
    /**
     * Returns a lexically sorted list of the map keys.
     * 
     */
    public static CompletableFuture<KeysResult> keysPlain(KeysPlainArgs args) {
        return keysPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a lexically sorted list of the map keys.
     * 
     */
    public static Output<KeysResult> keys(KeysArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:keys", TypeShape.of(KeysResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a lexically sorted list of the map keys.
     * 
     */
    public static CompletableFuture<KeysResult> keysPlain(KeysPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:keys", TypeShape.of(KeysResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines the length of a given list, map, or string.
     * 
     */
    public static Output<LengthResult> length(LengthArgs args) {
        return length(args, InvokeOptions.Empty);
    }
    /**
     * Determines the length of a given list, map, or string.
     * 
     */
    public static CompletableFuture<LengthResult> lengthPlain(LengthPlainArgs args) {
        return lengthPlain(args, InvokeOptions.Empty);
    }
    /**
     * Determines the length of a given list, map, or string.
     * 
     */
    public static Output<LengthResult> length(LengthArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:length", TypeShape.of(LengthResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines the length of a given list, map, or string.
     * 
     */
    public static CompletableFuture<LengthResult> lengthPlain(LengthPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:length", TypeShape.of(LengthResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static Output<LogResult> log(LogArgs args) {
        return log(args, InvokeOptions.Empty);
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static CompletableFuture<LogResult> logPlain(LogPlainArgs args) {
        return logPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static Output<LogResult> log(LogArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:log", TypeShape.of(LogResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static CompletableFuture<LogResult> logPlain(LogPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:log", TypeShape.of(LogResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Performs a dynamic lookup into a map variable.
     * 
     */
    public static Output<LookupResult> lookup(LookupArgs args) {
        return lookup(args, InvokeOptions.Empty);
    }
    /**
     * Performs a dynamic lookup into a map variable.
     * 
     */
    public static CompletableFuture<LookupResult> lookupPlain(LookupPlainArgs args) {
        return lookupPlain(args, InvokeOptions.Empty);
    }
    /**
     * Performs a dynamic lookup into a map variable.
     * 
     */
    public static Output<LookupResult> lookup(LookupArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:lookup", TypeShape.of(LookupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Performs a dynamic lookup into a map variable.
     * 
     */
    public static CompletableFuture<LookupResult> lookupPlain(LookupPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:lookup", TypeShape.of(LookupResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a copy of the string with all Unicode letters mapped to their lower case.
     * 
     */
    public static Output<LowerResult> lower(LowerArgs args) {
        return lower(args, InvokeOptions.Empty);
    }
    /**
     * Returns a copy of the string with all Unicode letters mapped to their lower case.
     * 
     */
    public static CompletableFuture<LowerResult> lowerPlain(LowerPlainArgs args) {
        return lowerPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a copy of the string with all Unicode letters mapped to their lower case.
     * 
     */
    public static Output<LowerResult> lower(LowerArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:lower", TypeShape.of(LowerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a copy of the string with all Unicode letters mapped to their lower case.
     * 
     */
    public static CompletableFuture<LowerResult> lowerPlain(LowerPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:lower", TypeShape.of(LowerResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a map consisting of the key/value pairs specified as arguments.
     * 
     */
    public static Output<MapResult> map(MapArgs args) {
        return map(args, InvokeOptions.Empty);
    }
    /**
     * Returns a map consisting of the key/value pairs specified as arguments.
     * 
     */
    public static CompletableFuture<MapResult> mapPlain(MapPlainArgs args) {
        return mapPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a map consisting of the key/value pairs specified as arguments.
     * 
     */
    public static Output<MapResult> map(MapArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:map", TypeShape.of(MapResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a map consisting of the key/value pairs specified as arguments.
     * 
     */
    public static CompletableFuture<MapResult> mapPlain(MapPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:map", TypeShape.of(MapResult.class), args, Utilities.withVersion(options));
    }
    /**
     * For two lists values and keys of equal length,
     * returns all elements from values where the corresponding element from keys exists in the searchset list.
     * 
     */
    public static Output<MatchkeysResult> matchkeys(MatchkeysArgs args) {
        return matchkeys(args, InvokeOptions.Empty);
    }
    /**
     * For two lists values and keys of equal length,
     * returns all elements from values where the corresponding element from keys exists in the searchset list.
     * 
     */
    public static CompletableFuture<MatchkeysResult> matchkeysPlain(MatchkeysPlainArgs args) {
        return matchkeysPlain(args, InvokeOptions.Empty);
    }
    /**
     * For two lists values and keys of equal length,
     * returns all elements from values where the corresponding element from keys exists in the searchset list.
     * 
     */
    public static Output<MatchkeysResult> matchkeys(MatchkeysArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:matchkeys", TypeShape.of(MatchkeysResult.class), args, Utilities.withVersion(options));
    }
    /**
     * For two lists values and keys of equal length,
     * returns all elements from values where the corresponding element from keys exists in the searchset list.
     * 
     */
    public static CompletableFuture<MatchkeysResult> matchkeysPlain(MatchkeysPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:matchkeys", TypeShape.of(MatchkeysResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the largest of the floats.
     * 
     */
    public static Output<MaxResult> max(MaxArgs args) {
        return max(args, InvokeOptions.Empty);
    }
    /**
     * Returns the largest of the floats.
     * 
     */
    public static CompletableFuture<MaxResult> maxPlain(MaxPlainArgs args) {
        return maxPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the largest of the floats.
     * 
     */
    public static Output<MaxResult> max(MaxArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:max", TypeShape.of(MaxResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the largest of the floats.
     * 
     */
    public static CompletableFuture<MaxResult> maxPlain(MaxPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:max", TypeShape.of(MaxResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a (conventional) hexadecimal representation of the MD5 hash of the given string.
     * 
     */
    public static Output<Md5Result> md5(Md5Args args) {
        return md5(args, InvokeOptions.Empty);
    }
    /**
     * Returns a (conventional) hexadecimal representation of the MD5 hash of the given string.
     * 
     */
    public static CompletableFuture<Md5Result> md5Plain(Md5PlainArgs args) {
        return md5Plain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a (conventional) hexadecimal representation of the MD5 hash of the given string.
     * 
     */
    public static Output<Md5Result> md5(Md5Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:md5", TypeShape.of(Md5Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a (conventional) hexadecimal representation of the MD5 hash of the given string.
     * 
     */
    public static CompletableFuture<Md5Result> md5Plain(Md5PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:md5", TypeShape.of(Md5Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the union of 2 or more maps. The maps are consumed in the order provided,
     * and duplicate keys overwrite previous entries.
     * 
     */
    public static Output<MergeResult> merge(MergeArgs args) {
        return merge(args, InvokeOptions.Empty);
    }
    /**
     * Returns the union of 2 or more maps. The maps are consumed in the order provided,
     * and duplicate keys overwrite previous entries.
     * 
     */
    public static CompletableFuture<MergeResult> mergePlain(MergePlainArgs args) {
        return mergePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the union of 2 or more maps. The maps are consumed in the order provided,
     * and duplicate keys overwrite previous entries.
     * 
     */
    public static Output<MergeResult> merge(MergeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:merge", TypeShape.of(MergeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the union of 2 or more maps. The maps are consumed in the order provided,
     * and duplicate keys overwrite previous entries.
     * 
     */
    public static CompletableFuture<MergeResult> mergePlain(MergePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:merge", TypeShape.of(MergeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the smallest of the floats.
     * 
     */
    public static Output<MinResult> min(MinArgs args) {
        return min(args, InvokeOptions.Empty);
    }
    /**
     * Returns the smallest of the floats.
     * 
     */
    public static CompletableFuture<MinResult> minPlain(MinPlainArgs args) {
        return minPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the smallest of the floats.
     * 
     */
    public static Output<MinResult> min(MinArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:min", TypeShape.of(MinResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the smallest of the floats.
     * 
     */
    public static CompletableFuture<MinResult> minPlain(MinPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:min", TypeShape.of(MinResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Parses the given string as a representation of an integer in the specified base
     * and returns the resulting number. The base must be between 2 and 62 inclusive.
     * 	.
     * 
     */
    public static Output<ParseintResult> parseint(ParseintArgs args) {
        return parseint(args, InvokeOptions.Empty);
    }
    /**
     * Parses the given string as a representation of an integer in the specified base
     * and returns the resulting number. The base must be between 2 and 62 inclusive.
     * 	.
     * 
     */
    public static CompletableFuture<ParseintResult> parseintPlain(ParseintPlainArgs args) {
        return parseintPlain(args, InvokeOptions.Empty);
    }
    /**
     * Parses the given string as a representation of an integer in the specified base
     * and returns the resulting number. The base must be between 2 and 62 inclusive.
     * 	.
     * 
     */
    public static Output<ParseintResult> parseint(ParseintArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:parseint", TypeShape.of(ParseintResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Parses the given string as a representation of an integer in the specified base
     * and returns the resulting number. The base must be between 2 and 62 inclusive.
     * 	.
     * 
     */
    public static CompletableFuture<ParseintResult> parseintPlain(ParseintPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:parseint", TypeShape.of(ParseintResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a filepath string with ~ expanded to the home directory.
     * 
     */
    public static Output<PathexpandResult> pathexpand(PathexpandArgs args) {
        return pathexpand(args, InvokeOptions.Empty);
    }
    /**
     * Returns a filepath string with ~ expanded to the home directory.
     * 
     */
    public static CompletableFuture<PathexpandResult> pathexpandPlain(PathexpandPlainArgs args) {
        return pathexpandPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a filepath string with ~ expanded to the home directory.
     * 
     */
    public static Output<PathexpandResult> pathexpand(PathexpandArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:pathexpand", TypeShape.of(PathexpandResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a filepath string with ~ expanded to the home directory.
     * 
     */
    public static CompletableFuture<PathexpandResult> pathexpandPlain(PathexpandPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:pathexpand", TypeShape.of(PathexpandResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the base input raised to the power of the exponent.
     * 
     */
    public static Output<PowResult> pow(PowArgs args) {
        return pow(args, InvokeOptions.Empty);
    }
    /**
     * Returns the base input raised to the power of the exponent.
     * 
     */
    public static CompletableFuture<PowResult> powPlain(PowPlainArgs args) {
        return powPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the base input raised to the power of the exponent.
     * 
     */
    public static Output<PowResult> pow(PowArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:pow", TypeShape.of(PowResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the base input raised to the power of the exponent.
     * 
     */
    public static CompletableFuture<PowResult> powPlain(PowPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:pow", TypeShape.of(PowResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Generates a list of numbers using a start value, a limit value, and a step value.
     * Start and step may be omitted, in which case start defaults to zero and step defaults to either one or negative one
     * depending on whether limit is greater than or less than start.
     * 
     */
    public static Output<RangeResult> range(RangeArgs args) {
        return range(args, InvokeOptions.Empty);
    }
    /**
     * Generates a list of numbers using a start value, a limit value, and a step value.
     * Start and step may be omitted, in which case start defaults to zero and step defaults to either one or negative one
     * depending on whether limit is greater than or less than start.
     * 
     */
    public static CompletableFuture<RangeResult> rangePlain(RangePlainArgs args) {
        return rangePlain(args, InvokeOptions.Empty);
    }
    /**
     * Generates a list of numbers using a start value, a limit value, and a step value.
     * Start and step may be omitted, in which case start defaults to zero and step defaults to either one or negative one
     * depending on whether limit is greater than or less than start.
     * 
     */
    public static Output<RangeResult> range(RangeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:range", TypeShape.of(RangeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Generates a list of numbers using a start value, a limit value, and a step value.
     * Start and step may be omitted, in which case start defaults to zero and step defaults to either one or negative one
     * depending on whether limit is greater than or less than start.
     * 
     */
    public static CompletableFuture<RangeResult> rangePlain(RangePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:range", TypeShape.of(RangeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Does a search and replace on the given string.
     * All instances of search are replaced with the value of replace.
     * If search is wrapped in forward slashes, it is treated as a regular expression.
     * If using a regular expression, replace can reference subcaptures in the regular expression by
     * using $n where n is the index or name of the subcapture. If using a regular expression,
     * the syntax conforms to the re2 regular expression syntax.
     * 
     */
    public static Output<ReplaceResult> replace(ReplaceArgs args) {
        return replace(args, InvokeOptions.Empty);
    }
    /**
     * Does a search and replace on the given string.
     * All instances of search are replaced with the value of replace.
     * If search is wrapped in forward slashes, it is treated as a regular expression.
     * If using a regular expression, replace can reference subcaptures in the regular expression by
     * using $n where n is the index or name of the subcapture. If using a regular expression,
     * the syntax conforms to the re2 regular expression syntax.
     * 
     */
    public static CompletableFuture<ReplaceResult> replacePlain(ReplacePlainArgs args) {
        return replacePlain(args, InvokeOptions.Empty);
    }
    /**
     * Does a search and replace on the given string.
     * All instances of search are replaced with the value of replace.
     * If search is wrapped in forward slashes, it is treated as a regular expression.
     * If using a regular expression, replace can reference subcaptures in the regular expression by
     * using $n where n is the index or name of the subcapture. If using a regular expression,
     * the syntax conforms to the re2 regular expression syntax.
     * 
     */
    public static Output<ReplaceResult> replace(ReplaceArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:replace", TypeShape.of(ReplaceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Does a search and replace on the given string.
     * All instances of search are replaced with the value of replace.
     * If search is wrapped in forward slashes, it is treated as a regular expression.
     * If using a regular expression, replace can reference subcaptures in the regular expression by
     * using $n where n is the index or name of the subcapture. If using a regular expression,
     * the syntax conforms to the re2 regular expression syntax.
     * 
     */
    public static CompletableFuture<ReplaceResult> replacePlain(ReplacePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:replace", TypeShape.of(ReplaceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a sequence with the same elements but in reverse order.
     * 
     */
    public static Output<ReverseResult> reverse(ReverseArgs args) {
        return reverse(args, InvokeOptions.Empty);
    }
    /**
     * Returns a sequence with the same elements but in reverse order.
     * 
     */
    public static CompletableFuture<ReverseResult> reversePlain(ReversePlainArgs args) {
        return reversePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a sequence with the same elements but in reverse order.
     * 
     */
    public static Output<ReverseResult> reverse(ReverseArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:reverse", TypeShape.of(ReverseResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a sequence with the same elements but in reverse order.
     * 
     */
    public static CompletableFuture<ReverseResult> reversePlain(ReversePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:reverse", TypeShape.of(ReverseResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static Output<Rfc3339tounixResult> rfc3339tounix(Rfc3339tounixArgs args) {
        return rfc3339tounix(args, InvokeOptions.Empty);
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static CompletableFuture<Rfc3339tounixResult> rfc3339tounixPlain(Rfc3339tounixPlainArgs args) {
        return rfc3339tounixPlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static Output<Rfc3339tounixResult> rfc3339tounix(Rfc3339tounixArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:rfc3339tounix", TypeShape.of(Rfc3339tounixResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static CompletableFuture<Rfc3339tounixResult> rfc3339tounixPlain(Rfc3339tounixPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:rfc3339tounix", TypeShape.of(Rfc3339tounixResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Decrypts an RSA-encrypted ciphertext.
     * The cipher text must be base64-encoded and the key must be in PEM format.
     * 
     */
    public static Output<RsadecryptResult> rsadecrypt(RsadecryptArgs args) {
        return rsadecrypt(args, InvokeOptions.Empty);
    }
    /**
     * Decrypts an RSA-encrypted ciphertext.
     * The cipher text must be base64-encoded and the key must be in PEM format.
     * 
     */
    public static CompletableFuture<RsadecryptResult> rsadecryptPlain(RsadecryptPlainArgs args) {
        return rsadecryptPlain(args, InvokeOptions.Empty);
    }
    /**
     * Decrypts an RSA-encrypted ciphertext.
     * The cipher text must be base64-encoded and the key must be in PEM format.
     * 
     */
    public static Output<RsadecryptResult> rsadecrypt(RsadecryptArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:rsadecrypt", TypeShape.of(RsadecryptResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Decrypts an RSA-encrypted ciphertext.
     * The cipher text must be base64-encoded and the key must be in PEM format.
     * 
     */
    public static CompletableFuture<RsadecryptResult> rsadecryptPlain(RsadecryptPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:rsadecrypt", TypeShape.of(RsadecryptResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a hexadecimal representation of the SHA-1 hash of the given string.
     * 
     */
    public static Output<Sha1Result> sha1(Sha1Args args) {
        return sha1(args, InvokeOptions.Empty);
    }
    /**
     * Returns a hexadecimal representation of the SHA-1 hash of the given string.
     * 
     */
    public static CompletableFuture<Sha1Result> sha1Plain(Sha1PlainArgs args) {
        return sha1Plain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a hexadecimal representation of the SHA-1 hash of the given string.
     * 
     */
    public static Output<Sha1Result> sha1(Sha1Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:sha1", TypeShape.of(Sha1Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a hexadecimal representation of the SHA-1 hash of the given string.
     * 
     */
    public static CompletableFuture<Sha1Result> sha1Plain(Sha1PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:sha1", TypeShape.of(Sha1Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a hexadecimal representation of the SHA-256 hash of the given string.
     * 
     */
    public static Output<Sha256Result> sha256(Sha256Args args) {
        return sha256(args, InvokeOptions.Empty);
    }
    /**
     * Returns a hexadecimal representation of the SHA-256 hash of the given string.
     * 
     */
    public static CompletableFuture<Sha256Result> sha256Plain(Sha256PlainArgs args) {
        return sha256Plain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a hexadecimal representation of the SHA-256 hash of the given string.
     * 
     */
    public static Output<Sha256Result> sha256(Sha256Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:sha256", TypeShape.of(Sha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a hexadecimal representation of the SHA-256 hash of the given string.
     * 
     */
    public static CompletableFuture<Sha256Result> sha256Plain(Sha256PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:sha256", TypeShape.of(Sha256Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a hexadecimal representation of the SHA-512 hash of the given string.
     * 
     */
    public static Output<Sha512Result> sha512(Sha512Args args) {
        return sha512(args, InvokeOptions.Empty);
    }
    /**
     * Returns a hexadecimal representation of the SHA-512 hash of the given string.
     * 
     */
    public static CompletableFuture<Sha512Result> sha512Plain(Sha512PlainArgs args) {
        return sha512Plain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a hexadecimal representation of the SHA-512 hash of the given string.
     * 
     */
    public static Output<Sha512Result> sha512(Sha512Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:sha512", TypeShape.of(Sha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a hexadecimal representation of the SHA-512 hash of the given string.
     * 
     */
    public static CompletableFuture<Sha512Result> sha512Plain(Sha512PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:sha512", TypeShape.of(Sha512Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static Output<SignumResult> signum(SignumArgs args) {
        return signum(args, InvokeOptions.Empty);
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static CompletableFuture<SignumResult> signumPlain(SignumPlainArgs args) {
        return signumPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static Output<SignumResult> signum(SignumArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:signum", TypeShape.of(SignumResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the greatest integer value less than or equal to the argument.
     * 
     */
    public static CompletableFuture<SignumResult> signumPlain(SignumPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:signum", TypeShape.of(SignumResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the portion of list between from (inclusive) and to (exclusive).
     * 
     */
    public static Output<SliceResult> slice(SliceArgs args) {
        return slice(args, InvokeOptions.Empty);
    }
    /**
     * Returns the portion of list between from (inclusive) and to (exclusive).
     * 
     */
    public static CompletableFuture<SliceResult> slicePlain(SlicePlainArgs args) {
        return slicePlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the portion of list between from (inclusive) and to (exclusive).
     * 
     */
    public static Output<SliceResult> slice(SliceArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:slice", TypeShape.of(SliceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the portion of list between from (inclusive) and to (exclusive).
     * 
     */
    public static CompletableFuture<SliceResult> slicePlain(SlicePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:slice", TypeShape.of(SliceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a list of strings sorted lexicographically.
     * 
     */
    public static Output<SortResult> sort(SortArgs args) {
        return sort(args, InvokeOptions.Empty);
    }
    /**
     * Returns a list of strings sorted lexicographically.
     * 
     */
    public static CompletableFuture<SortResult> sortPlain(SortPlainArgs args) {
        return sortPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a list of strings sorted lexicographically.
     * 
     */
    public static Output<SortResult> sort(SortArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:sort", TypeShape.of(SortResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a list of strings sorted lexicographically.
     * 
     */
    public static CompletableFuture<SortResult> sortPlain(SortPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:sort", TypeShape.of(SortResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Produces a list by dividing a given string at all occurrences of a given separator
     * 
     */
    public static Output<SplitResult> split(SplitArgs args) {
        return split(args, InvokeOptions.Empty);
    }
    /**
     * Produces a list by dividing a given string at all occurrences of a given separator
     * 
     */
    public static CompletableFuture<SplitResult> splitPlain(SplitPlainArgs args) {
        return splitPlain(args, InvokeOptions.Empty);
    }
    /**
     * Produces a list by dividing a given string at all occurrences of a given separator
     * 
     */
    public static Output<SplitResult> split(SplitArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:split", TypeShape.of(SplitResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Produces a list by dividing a given string at all occurrences of a given separator
     * 
     */
    public static CompletableFuture<SplitResult> splitPlain(SplitPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:split", TypeShape.of(SplitResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines if the input string starts with the suffix.
     * 
     */
    public static Output<StartswithResult> startswith(StartswithArgs args) {
        return startswith(args, InvokeOptions.Empty);
    }
    /**
     * Determines if the input string starts with the suffix.
     * 
     */
    public static CompletableFuture<StartswithResult> startswithPlain(StartswithPlainArgs args) {
        return startswithPlain(args, InvokeOptions.Empty);
    }
    /**
     * Determines if the input string starts with the suffix.
     * 
     */
    public static Output<StartswithResult> startswith(StartswithArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:startswith", TypeShape.of(StartswithResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Determines if the input string starts with the suffix.
     * 
     */
    public static CompletableFuture<StartswithResult> startswithPlain(StartswithPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:startswith", TypeShape.of(StartswithResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the given string with all of its Unicode characters in reverse order.
     * 
     */
    public static Output<StrrevResult> strrev(StrrevArgs args) {
        return strrev(args, InvokeOptions.Empty);
    }
    /**
     * Returns the given string with all of its Unicode characters in reverse order.
     * 
     */
    public static CompletableFuture<StrrevResult> strrevPlain(StrrevPlainArgs args) {
        return strrevPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the given string with all of its Unicode characters in reverse order.
     * 
     */
    public static Output<StrrevResult> strrev(StrrevArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:strrev", TypeShape.of(StrrevResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the given string with all of its Unicode characters in reverse order.
     * 
     */
    public static CompletableFuture<StrrevResult> strrevPlain(StrrevPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:strrev", TypeShape.of(StrrevResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Extracts a substring from the given string.
     * 
     */
    public static Output<SubstrResult> substr(SubstrArgs args) {
        return substr(args, InvokeOptions.Empty);
    }
    /**
     * Extracts a substring from the given string.
     * 
     */
    public static CompletableFuture<SubstrResult> substrPlain(SubstrPlainArgs args) {
        return substrPlain(args, InvokeOptions.Empty);
    }
    /**
     * Extracts a substring from the given string.
     * 
     */
    public static Output<SubstrResult> substr(SubstrArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:substr", TypeShape.of(SubstrResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Extracts a substring from the given string.
     * 
     */
    public static CompletableFuture<SubstrResult> substrPlain(SubstrPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:substr", TypeShape.of(SubstrResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the total sum of the elements of the input list.
     * 
     */
    public static Output<SumResult> sum(SumArgs args) {
        return sum(args, InvokeOptions.Empty);
    }
    /**
     * Returns the total sum of the elements of the input list.
     * 
     */
    public static CompletableFuture<SumResult> sumPlain(SumPlainArgs args) {
        return sumPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns the total sum of the elements of the input list.
     * 
     */
    public static Output<SumResult> sum(SumArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:sum", TypeShape.of(SumResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns the total sum of the elements of the input list.
     * 
     */
    public static CompletableFuture<SumResult> sumPlain(SumPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:sum", TypeShape.of(SumResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Adds a duration to a timestamp, returning a new timestamp.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	&#39;timestamp&#39; must be a string adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	&#39;duration&#39; is a string representation of a time difference, comprised of sequences of
     * 	numbers and unit pairs, i.e. &#34;3.5h&#34; or &#34;2h15m&#34;.
     * 	Accepted units are &#34;ns&#34;, &#34;us&#34; or &#34;s&#34;, &#34;ms&#34;, &#34;s&#34;, &#34;m&#34;, and &#34;h&#34;. The first number may be negative
     * 	to provide a negative duration, i.e. &#34;-2h15m&#34;.
     * 
     */
    public static Output<TimeaddResult> timeadd(TimeaddArgs args) {
        return timeadd(args, InvokeOptions.Empty);
    }
    /**
     * Adds a duration to a timestamp, returning a new timestamp.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	&#39;timestamp&#39; must be a string adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	&#39;duration&#39; is a string representation of a time difference, comprised of sequences of
     * 	numbers and unit pairs, i.e. &#34;3.5h&#34; or &#34;2h15m&#34;.
     * 	Accepted units are &#34;ns&#34;, &#34;us&#34; or &#34;s&#34;, &#34;ms&#34;, &#34;s&#34;, &#34;m&#34;, and &#34;h&#34;. The first number may be negative
     * 	to provide a negative duration, i.e. &#34;-2h15m&#34;.
     * 
     */
    public static CompletableFuture<TimeaddResult> timeaddPlain(TimeaddPlainArgs args) {
        return timeaddPlain(args, InvokeOptions.Empty);
    }
    /**
     * Adds a duration to a timestamp, returning a new timestamp.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	&#39;timestamp&#39; must be a string adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	&#39;duration&#39; is a string representation of a time difference, comprised of sequences of
     * 	numbers and unit pairs, i.e. &#34;3.5h&#34; or &#34;2h15m&#34;.
     * 	Accepted units are &#34;ns&#34;, &#34;us&#34; or &#34;s&#34;, &#34;ms&#34;, &#34;s&#34;, &#34;m&#34;, and &#34;h&#34;. The first number may be negative
     * 	to provide a negative duration, i.e. &#34;-2h15m&#34;.
     * 
     */
    public static Output<TimeaddResult> timeadd(TimeaddArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:timeadd", TypeShape.of(TimeaddResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Adds a duration to a timestamp, returning a new timestamp.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	&#39;timestamp&#39; must be a string adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	&#39;duration&#39; is a string representation of a time difference, comprised of sequences of
     * 	numbers and unit pairs, i.e. &#34;3.5h&#34; or &#34;2h15m&#34;.
     * 	Accepted units are &#34;ns&#34;, &#34;us&#34; or &#34;s&#34;, &#34;ms&#34;, &#34;s&#34;, &#34;m&#34;, and &#34;h&#34;. The first number may be negative
     * 	to provide a negative duration, i.e. &#34;-2h15m&#34;.
     * 
     */
    public static CompletableFuture<TimeaddResult> timeaddPlain(TimeaddPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:timeadd", TypeShape.of(TimeaddResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Compares two timestamps and returns a number that represents the ordering
     * 	of the instants those timestamps represent.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	Both timestamps must be strings adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	If &#39;timestamp_a&#39; is before &#39;timestamp_b&#39;, -1 is returned.
     * 	If &#39;timestamp_a&#39; is equal to &#39;timestamp_b&#39;, 0 is returned.
     * 	If &#39;timestamp_a&#39; is after &#39;timestamp_b&#39;, 1 is returned.
     * 
     */
    public static Output<TimecmpResult> timecmp(TimecmpArgs args) {
        return timecmp(args, InvokeOptions.Empty);
    }
    /**
     * Compares two timestamps and returns a number that represents the ordering
     * 	of the instants those timestamps represent.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	Both timestamps must be strings adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	If &#39;timestamp_a&#39; is before &#39;timestamp_b&#39;, -1 is returned.
     * 	If &#39;timestamp_a&#39; is equal to &#39;timestamp_b&#39;, 0 is returned.
     * 	If &#39;timestamp_a&#39; is after &#39;timestamp_b&#39;, 1 is returned.
     * 
     */
    public static CompletableFuture<TimecmpResult> timecmpPlain(TimecmpPlainArgs args) {
        return timecmpPlain(args, InvokeOptions.Empty);
    }
    /**
     * Compares two timestamps and returns a number that represents the ordering
     * 	of the instants those timestamps represent.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	Both timestamps must be strings adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	If &#39;timestamp_a&#39; is before &#39;timestamp_b&#39;, -1 is returned.
     * 	If &#39;timestamp_a&#39; is equal to &#39;timestamp_b&#39;, 0 is returned.
     * 	If &#39;timestamp_a&#39; is after &#39;timestamp_b&#39;, 1 is returned.
     * 
     */
    public static Output<TimecmpResult> timecmp(TimecmpArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:timecmp", TypeShape.of(TimecmpResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Compares two timestamps and returns a number that represents the ordering
     * 	of the instants those timestamps represent.
     * 	Timestamps are represented as strings using RFC 3339 &#34;Date and time format&#34; syntax.
     * 	Both timestamps must be strings adhering this syntax, i.e. &#34;2017-11-22T00:00:00Z&#34;.
     * 	If &#39;timestamp_a&#39; is before &#39;timestamp_b&#39;, -1 is returned.
     * 	If &#39;timestamp_a&#39; is equal to &#39;timestamp_b&#39;, 0 is returned.
     * 	If &#39;timestamp_a&#39; is after &#39;timestamp_b&#39;, 1 is returned.
     * 
     */
    public static CompletableFuture<TimecmpResult> timecmpPlain(TimecmpPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:timecmp", TypeShape.of(TimecmpResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a UTC timestamp string of the current time in RFC 3339 format
     * 
     */
    public static Output<TimestampResult> timestamp() {
        return timestamp(TimestampArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Returns a UTC timestamp string of the current time in RFC 3339 format
     * 
     */
    public static CompletableFuture<TimestampResult> timestampPlain() {
        return timestampPlain(TimestampPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Returns a UTC timestamp string of the current time in RFC 3339 format
     * 
     */
    public static Output<TimestampResult> timestamp(TimestampArgs args) {
        return timestamp(args, InvokeOptions.Empty);
    }
    /**
     * Returns a UTC timestamp string of the current time in RFC 3339 format
     * 
     */
    public static CompletableFuture<TimestampResult> timestampPlain(TimestampPlainArgs args) {
        return timestampPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a UTC timestamp string of the current time in RFC 3339 format
     * 
     */
    public static Output<TimestampResult> timestamp(TimestampArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:timestamp", TypeShape.of(TimestampResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a UTC timestamp string of the current time in RFC 3339 format
     * 
     */
    public static CompletableFuture<TimestampResult> timestampPlain(TimestampPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:timestamp", TypeShape.of(TimestampResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts the first letter of each word in the given string to uppercase.
     * 
     */
    public static Output<TitleResult> title(TitleArgs args) {
        return title(args, InvokeOptions.Empty);
    }
    /**
     * Converts the first letter of each word in the given string to uppercase.
     * 
     */
    public static CompletableFuture<TitleResult> titlePlain(TitlePlainArgs args) {
        return titlePlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts the first letter of each word in the given string to uppercase.
     * 
     */
    public static Output<TitleResult> title(TitleArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:title", TypeShape.of(TitleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts the first letter of each word in the given string to uppercase.
     * 
     */
    public static CompletableFuture<TitleResult> titlePlain(TitlePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:title", TypeShape.of(TitleResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a boolean value. Only boolean values, null, and the exact strings
     * 	&#34;true&#34; and &#34;false&#34; can be converted to boolean. All other values will result in an error.
     * 
     */
    public static Output<ToboolResult> tobool(ToboolArgs args) {
        return tobool(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a boolean value. Only boolean values, null, and the exact strings
     * 	&#34;true&#34; and &#34;false&#34; can be converted to boolean. All other values will result in an error.
     * 
     */
    public static CompletableFuture<ToboolResult> toboolPlain(ToboolPlainArgs args) {
        return toboolPlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a boolean value. Only boolean values, null, and the exact strings
     * 	&#34;true&#34; and &#34;false&#34; can be converted to boolean. All other values will result in an error.
     * 
     */
    public static Output<ToboolResult> tobool(ToboolArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:tobool", TypeShape.of(ToboolResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a boolean value. Only boolean values, null, and the exact strings
     * 	&#34;true&#34; and &#34;false&#34; can be converted to boolean. All other values will result in an error.
     * 
     */
    public static CompletableFuture<ToboolResult> toboolPlain(ToboolPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:tobool", TypeShape.of(ToboolResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a list value.
     * 
     */
    public static Output<TolistResult> tolist(TolistArgs args) {
        return tolist(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a list value.
     * 
     */
    public static CompletableFuture<TolistResult> tolistPlain(TolistPlainArgs args) {
        return tolistPlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a list value.
     * 
     */
    public static Output<TolistResult> tolist(TolistArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:tolist", TypeShape.of(TolistResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a list value.
     * 
     */
    public static CompletableFuture<TolistResult> tolistPlain(TolistPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:tolist", TypeShape.of(TolistResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a number value. Only number values, null, and strings
     * 	containing decimal representations of numbers can be converted to number. All other values will result in an error
     * 
     */
    public static Output<TonumberResult> tonumber(TonumberArgs args) {
        return tonumber(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a number value. Only number values, null, and strings
     * 	containing decimal representations of numbers can be converted to number. All other values will result in an error
     * 
     */
    public static CompletableFuture<TonumberResult> tonumberPlain(TonumberPlainArgs args) {
        return tonumberPlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a number value. Only number values, null, and strings
     * 	containing decimal representations of numbers can be converted to number. All other values will result in an error
     * 
     */
    public static Output<TonumberResult> tonumber(TonumberArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:tonumber", TypeShape.of(TonumberResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a number value. Only number values, null, and strings
     * 	containing decimal representations of numbers can be converted to number. All other values will result in an error
     * 
     */
    public static CompletableFuture<TonumberResult> tonumberPlain(TonumberPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:tonumber", TypeShape.of(TonumberResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a set value.
     * 
     */
    public static Output<TosetResult> toset(TosetArgs args) {
        return toset(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a set value.
     * 
     */
    public static CompletableFuture<TosetResult> tosetPlain(TosetPlainArgs args) {
        return tosetPlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a set value.
     * 
     */
    public static Output<TosetResult> toset(TosetArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:toset", TypeShape.of(TosetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a set value.
     * 
     */
    public static CompletableFuture<TosetResult> tosetPlain(TosetPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:toset", TypeShape.of(TosetResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a string value. Only primitive types (string, number, bool)
     * 	and null can be converted to string. All other values will result in an error.
     * 
     */
    public static Output<TostringResult> tostring(TostringArgs args) {
        return tostring(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a string value. Only primitive types (string, number, bool)
     * 	and null can be converted to string. All other values will result in an error.
     * 
     */
    public static CompletableFuture<TostringResult> tostringPlain(TostringPlainArgs args) {
        return tostringPlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts its argument to a string value. Only primitive types (string, number, bool)
     * 	and null can be converted to string. All other values will result in an error.
     * 
     */
    public static Output<TostringResult> tostring(TostringArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:tostring", TypeShape.of(TostringResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts its argument to a string value. Only primitive types (string, number, bool)
     * 	and null can be converted to string. All other values will result in an error.
     * 
     */
    public static CompletableFuture<TostringResult> tostringPlain(TostringPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:tostring", TypeShape.of(TostringResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes a map of lists of strings and swaps the keys and values to return a new map of lists of strings.
     * 
     */
    public static Output<TransposeResult> transpose(TransposeArgs args) {
        return transpose(args, InvokeOptions.Empty);
    }
    /**
     * Takes a map of lists of strings and swaps the keys and values to return a new map of lists of strings.
     * 
     */
    public static CompletableFuture<TransposeResult> transposePlain(TransposePlainArgs args) {
        return transposePlain(args, InvokeOptions.Empty);
    }
    /**
     * Takes a map of lists of strings and swaps the keys and values to return a new map of lists of strings.
     * 
     */
    public static Output<TransposeResult> transpose(TransposeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:transpose", TypeShape.of(TransposeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Takes a map of lists of strings and swaps the keys and values to return a new map of lists of strings.
     * 
     */
    public static CompletableFuture<TransposeResult> transposePlain(TransposePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:transpose", TypeShape.of(TransposeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes the specified set of characters from the start and end of the given string.
     * 
     */
    public static Output<TrimResult> trim(TrimArgs args) {
        return trim(args, InvokeOptions.Empty);
    }
    /**
     * Removes the specified set of characters from the start and end of the given string.
     * 
     */
    public static CompletableFuture<TrimResult> trimPlain(TrimPlainArgs args) {
        return trimPlain(args, InvokeOptions.Empty);
    }
    /**
     * Removes the specified set of characters from the start and end of the given string.
     * 
     */
    public static Output<TrimResult> trim(TrimArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:trim", TypeShape.of(TrimResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes the specified set of characters from the start and end of the given string.
     * 
     */
    public static CompletableFuture<TrimResult> trimPlain(TrimPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:trim", TypeShape.of(TrimResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes the specified prefix from the start of the given string, if present.
     * 
     */
    public static Output<TrimprefixResult> trimprefix(TrimprefixArgs args) {
        return trimprefix(args, InvokeOptions.Empty);
    }
    /**
     * Removes the specified prefix from the start of the given string, if present.
     * 
     */
    public static CompletableFuture<TrimprefixResult> trimprefixPlain(TrimprefixPlainArgs args) {
        return trimprefixPlain(args, InvokeOptions.Empty);
    }
    /**
     * Removes the specified prefix from the start of the given string, if present.
     * 
     */
    public static Output<TrimprefixResult> trimprefix(TrimprefixArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:trimprefix", TypeShape.of(TrimprefixResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes the specified prefix from the start of the given string, if present.
     * 
     */
    public static CompletableFuture<TrimprefixResult> trimprefixPlain(TrimprefixPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:trimprefix", TypeShape.of(TrimprefixResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes any space characters from the start and end of the given string,
     * 	following the Unicode definition of \&#34;space\&#34; (i.e. spaces, tabs, newline, etc.).
     * 
     */
    public static Output<TrimspaceResult> trimspace(TrimspaceArgs args) {
        return trimspace(args, InvokeOptions.Empty);
    }
    /**
     * Removes any space characters from the start and end of the given string,
     * 	following the Unicode definition of \&#34;space\&#34; (i.e. spaces, tabs, newline, etc.).
     * 
     */
    public static CompletableFuture<TrimspaceResult> trimspacePlain(TrimspacePlainArgs args) {
        return trimspacePlain(args, InvokeOptions.Empty);
    }
    /**
     * Removes any space characters from the start and end of the given string,
     * 	following the Unicode definition of \&#34;space\&#34; (i.e. spaces, tabs, newline, etc.).
     * 
     */
    public static Output<TrimspaceResult> trimspace(TrimspaceArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:trimspace", TypeShape.of(TrimspaceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes any space characters from the start and end of the given string,
     * 	following the Unicode definition of \&#34;space\&#34; (i.e. spaces, tabs, newline, etc.).
     * 
     */
    public static CompletableFuture<TrimspaceResult> trimspacePlain(TrimspacePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:trimspace", TypeShape.of(TrimspaceResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes the specified suffix from the end of the given string, if present.
     * 
     */
    public static Output<TrimsuffixResult> trimsuffix(TrimsuffixArgs args) {
        return trimsuffix(args, InvokeOptions.Empty);
    }
    /**
     * Removes the specified suffix from the end of the given string, if present.
     * 
     */
    public static CompletableFuture<TrimsuffixResult> trimsuffixPlain(TrimsuffixPlainArgs args) {
        return trimsuffixPlain(args, InvokeOptions.Empty);
    }
    /**
     * Removes the specified suffix from the end of the given string, if present.
     * 
     */
    public static Output<TrimsuffixResult> trimsuffix(TrimsuffixArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:trimsuffix", TypeShape.of(TrimsuffixResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Removes the specified suffix from the end of the given string, if present.
     * 
     */
    public static CompletableFuture<TrimsuffixResult> trimsuffixPlain(TrimsuffixPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:trimsuffix", TypeShape.of(TrimsuffixResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static Output<Unixtorfc3999Result> unixtorfc3999(Unixtorfc3999Args args) {
        return unixtorfc3999(args, InvokeOptions.Empty);
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static CompletableFuture<Unixtorfc3999Result> unixtorfc3999Plain(Unixtorfc3999PlainArgs args) {
        return unixtorfc3999Plain(args, InvokeOptions.Empty);
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static Output<Unixtorfc3999Result> unixtorfc3999(Unixtorfc3999Args args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:unixtorfc3999", TypeShape.of(Unixtorfc3999Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts a RFC3999 formatted timestamp into a Unix timestamp with milliseconds.
     * 
     */
    public static CompletableFuture<Unixtorfc3999Result> unixtorfc3999Plain(Unixtorfc3999PlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:unixtorfc3999", TypeShape.of(Unixtorfc3999Result.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts all cased letters in the given string to uppercase.
     * 
     */
    public static Output<UpperResult> upper(UpperArgs args) {
        return upper(args, InvokeOptions.Empty);
    }
    /**
     * Converts all cased letters in the given string to uppercase.
     * 
     */
    public static CompletableFuture<UpperResult> upperPlain(UpperPlainArgs args) {
        return upperPlain(args, InvokeOptions.Empty);
    }
    /**
     * Converts all cased letters in the given string to uppercase.
     * 
     */
    public static Output<UpperResult> upper(UpperArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:upper", TypeShape.of(UpperResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Converts all cased letters in the given string to uppercase.
     * 
     */
    public static CompletableFuture<UpperResult> upperPlain(UpperPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:upper", TypeShape.of(UpperResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Applies URL encoding to a given string.
     * 
     */
    public static Output<UrlencodeResult> urlencode(UrlencodeArgs args) {
        return urlencode(args, InvokeOptions.Empty);
    }
    /**
     * Applies URL encoding to a given string.
     * 
     */
    public static CompletableFuture<UrlencodeResult> urlencodePlain(UrlencodePlainArgs args) {
        return urlencodePlain(args, InvokeOptions.Empty);
    }
    /**
     * Applies URL encoding to a given string.
     * 
     */
    public static Output<UrlencodeResult> urlencode(UrlencodeArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:urlencode", TypeShape.of(UrlencodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Applies URL encoding to a given string.
     * 
     */
    public static CompletableFuture<UrlencodeResult> urlencodePlain(UrlencodePlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:urlencode", TypeShape.of(UrlencodeResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a unique identifier string, generated and formatted as required by RFC 4122.
     * 
     */
    public static Output<UuidResult> uuid() {
        return uuid(UuidArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Returns a unique identifier string, generated and formatted as required by RFC 4122.
     * 
     */
    public static CompletableFuture<UuidResult> uuidPlain() {
        return uuidPlain(UuidPlainArgs.Empty, InvokeOptions.Empty);
    }
    /**
     * Returns a unique identifier string, generated and formatted as required by RFC 4122.
     * 
     */
    public static Output<UuidResult> uuid(UuidArgs args) {
        return uuid(args, InvokeOptions.Empty);
    }
    /**
     * Returns a unique identifier string, generated and formatted as required by RFC 4122.
     * 
     */
    public static CompletableFuture<UuidResult> uuidPlain(UuidPlainArgs args) {
        return uuidPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a unique identifier string, generated and formatted as required by RFC 4122.
     * 
     */
    public static Output<UuidResult> uuid(UuidArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:uuid", TypeShape.of(UuidResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a unique identifier string, generated and formatted as required by RFC 4122.
     * 
     */
    public static CompletableFuture<UuidResult> uuidPlain(UuidPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:uuid", TypeShape.of(UuidResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a list of the values of the map.
     * 
     */
    public static Output<ValuesResult> values(ValuesArgs args) {
        return values(args, InvokeOptions.Empty);
    }
    /**
     * Returns a list of the values of the map.
     * 
     */
    public static CompletableFuture<ValuesResult> valuesPlain(ValuesPlainArgs args) {
        return valuesPlain(args, InvokeOptions.Empty);
    }
    /**
     * Returns a list of the values of the map.
     * 
     */
    public static Output<ValuesResult> values(ValuesArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:values", TypeShape.of(ValuesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Returns a list of the values of the map.
     * 
     */
    public static CompletableFuture<ValuesResult> valuesPlain(ValuesPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:values", TypeShape.of(ValuesResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Constructs a map from a list of keys and a corresponding list of values.
     * 
     */
    public static Output<ZipmapResult> zipmap(ZipmapArgs args) {
        return zipmap(args, InvokeOptions.Empty);
    }
    /**
     * Constructs a map from a list of keys and a corresponding list of values.
     * 
     */
    public static CompletableFuture<ZipmapResult> zipmapPlain(ZipmapPlainArgs args) {
        return zipmapPlain(args, InvokeOptions.Empty);
    }
    /**
     * Constructs a map from a list of keys and a corresponding list of values.
     * 
     */
    public static Output<ZipmapResult> zipmap(ZipmapArgs args, InvokeOptions options) {
        return Deployment.getInstance().invoke("std:index:zipmap", TypeShape.of(ZipmapResult.class), args, Utilities.withVersion(options));
    }
    /**
     * Constructs a map from a list of keys and a corresponding list of values.
     * 
     */
    public static CompletableFuture<ZipmapResult> zipmapPlain(ZipmapPlainArgs args, InvokeOptions options) {
        return Deployment.getInstance().invokeAsync("std:index:zipmap", TypeShape.of(ZipmapResult.class), args, Utilities.withVersion(options));
    }
}
